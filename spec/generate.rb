ADAPTER_SPECS = [:null_stringkey_stringvalue, :store_stringkey_stringvalue, :returndifferent_stringkey_stringvalue]
SIMPLE_SPECS = [:null, :store, :returndifferent, :marshallable_key, :marshallable_value, :bypass_transformer]
EXPIRES_SPECS = SIMPLE_SPECS + [:expires_stringkey_stringvalue]
header = "# Generated by #{__FILE__}\n"

TESTS = {
  'simple_client_tcp' => {
    :preamble => "$tcp_server ||= Moneta::Server.new(Moneta.new(:Memory))\n",
    :store => :Client,
    :tests => %{
it 'should support multiple clients' do
  client = Moneta.new(:Client)
  client['shared_key'] = 'shared_val'
  (1..100).each do |i|
    Thread.new do
      client = Moneta.new(:Client)
      (1.100).each do |j|
        client['shared_key'].should == 'shared_val'
        client["key-\#{j}-\#{i}"] = "val-\#{j}-\#{i}"
        client["key-\#{j}-\#{i}"].should == "val-\#{j}-\#{i}"
      end
    end
  end
end
}
  },
  'simple_client_unix' => {
    :preamble => "$unix_server ||= Moneta::Server.new(Moneta.new(:Memory), :file => File.join(make_tempdir, 'simple_client_unix'))\nafter(:all) { $unix_server.stop; $unix_server = nil }\n",
    :store => :Client,
    :options => ":file => File.join(make_tempdir, 'simple_client_unix')"
  },
  'simple_memory' => {
    :store => :Memory
  },
  'simple_memory_with_expires' => {
    :store => :Memory,
    :options => ':expires => true',
    :specs => EXPIRES_SPECS,
  },
  'simple_memory_with_compress' => {
    :store => :Memory,
    :options => ':compress => true',
    :specs => [:null, :store, :returndifferent, :marshallable_key, :marshallable_value]
  },
  'simple_memory_with_prefix' => {
    :store => :Memory,
    :options => ':prefix => "moneta"',
  },
  'simple_memory_with_json_serializer' => {
    :store => :Memory,
    :options => ':serializer => :json',
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
  },
  'simple_memory_with_json_key_serializer' => {
    :store => :Memory,
    :options => ':key_serializer => :json',
    :key => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
  },
  'simple_memory_with_json_md5_key_serializer' => {
    :store => :Memory,
    :options => ':key_serializer => [:json, :md5]',
    :key => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
  },
  'simple_memory_with_json_value_serializer' => {
    :store => :Memory,
    :options => ':value_serializer => :json',
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent, :marshallable_key],
  },
  'simple_memory_with_quicklz_compress' => {
    :store => :Memory,
    :options => ':compress => :quicklz',
    :specs => [:null, :store, :returndifferent, :marshallable_key, :marshallable_value]
  },
  'simple_lruhash' => {
    :store => :LRUHash,
  },
  'simple_lruhash_with_expires' => {
    :store => :LRUHash,
    :options => ':expires => true',
    :specs => EXPIRES_SPECS,
  },
  'simple_file' => {
    :store => :File,
    :options => ':dir => File.join(make_tempdir, "simple_file")'
  },
  'simple_file_with_expires' => {
    :store => :File,
    :options => ':dir => File.join(make_tempdir, "simple_file_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_hashfile' => {
    :store => :HashFile,
    :options => ':dir => File.join(make_tempdir, "simple_hashfile")'
  },
  'simple_hashfile_with_expires' => {
    :store => :HashFile,
    :options => ':dir => File.join(make_tempdir, "simple_hashfile_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_cassandra' => {
    :store => :Cassandra,
    :options => ':keyspace => "simple_cassandra"',
    :specs => EXPIRES_SPECS,
  },
  'simple_hbase' => {
    :store => :HBase,
    :options => ':table => "simple_hbase"',
  },
  'simple_hbase_with_expires' => {
    :store => :HBase,
    :options => ':table => "simple_hbase", :expires => true',
    :specs => EXPIRES_SPECS,
  },
  'simple_dbm' => {
    :store => :DBM,
    :options => ':file => File.join(make_tempdir, "simple_dbm")'
  },
  'simple_dbm_with_expires' => {
    :store => :DBM,
    :options => ':file => File.join(make_tempdir, "simple_dbm_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_gdbm' => {
    :store => :GDBM,
    :options => ':file => File.join(make_tempdir, "simple_gdbm")'
  },
  'simple_gdbm_with_expires' => {
    :store => :GDBM,
    :options => ':file => File.join(make_tempdir, "simple_gdbm_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_sdbm' => {
    :store => :SDBM,
    :options => ':file => File.join(make_tempdir, "simple_sdbm")'
  },
  'simple_sdbm_with_expires' => {
    :store => :SDBM,
    :options => ':file => File.join(make_tempdir, "simple_sdbm_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_leveldb' => {
    :store => :LevelDB,
    :options => ':dir => File.join(make_tempdir, "simple_leveldb")'
  },
  'simple_leveldb_with_expires' => {
    :store => :LevelDB,
    :options => ':dir => File.join(make_tempdir, "simple_leveldb_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_pstore' => {
    :store => :PStore,
    :options => ':file => File.join(make_tempdir, "simple_pstore")'
  },
  'simple_pstore_with_expires' => {
    :store => :PStore,
    :options => ':file => File.join(make_tempdir, "simple_pstore_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_yaml' => {
    :store => :YAML,
    :options => ':file => File.join(make_tempdir, "simple_yaml")',
    :specs => [:null, :store, :returndifferent, :marshallable_key],
  },
  'simple_yaml_with_expires' => {
    :store => :YAML,
    :options => ':file => File.join(make_tempdir, "simple_yaml_with_expires"), :expires => true',
    :specs => [:null, :store, :returndifferent, :marshallable_key, :expires_stringkey_stringvalue],
  },
  'simple_localmemcache' => {
    :store => :LocalMemCache,
    :options => ':file => File.join(make_tempdir, "simple_localmemcache")'
  },
  'simple_localmemcache_with_expires' => {
    :store => :LocalMemCache,
    :options => ':file => File.join(make_tempdir, "simple_localmemcache_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_tokyocabinet' => {
    :store => :TokyoCabinet,
    :options => ':file => File.join(make_tempdir, "simple_tokyocabinet")'
  },
  'simple_tokyocabinet_with_expires' => {
    :store => :TokyoCabinet,
    :options => ':file => File.join(make_tempdir, "simple_tokyocabinet_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_sqlite' => {
    :store => :Sqlite,
    :options => ':file => File.join(make_tempdir, "simple_sqlite")'
  },
  'simple_sqlite_with_expires' => {
    :store => :Sqlite,
    :options => ':file => File.join(make_tempdir, "simple_sqlite_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_redis' => {
    :store => :Redis,
    :specs => EXPIRES_SPECS,
  },
  'simple_memcached' => {
    :store => :Memcached,
    :specs => EXPIRES_SPECS,
    :options => ':namespace => "simple_memcached"'
  },
  'simple_memcached_dalli' => {
    :store => :MemcachedDalli,
    :specs => EXPIRES_SPECS,
    :options => ':namespace => "simple_memcached_dalli"'
  },
  'simple_memcached_native' => {
    :store => :MemcachedNative,
    :specs => EXPIRES_SPECS,
    :options => ':namespace => "simple_memcached_native"'
  },
  'simple_riak' => {
    :store => :Riak,
    :options => ":bucket => 'simple_riak'",
    # We don't want Riak warnings in tests
    :preamble => "require 'riak'\n\nRiak.disable_list_keys_warnings = true\n\n"
  },
  'simple_riak_with_expires' => {
    :store => :Riak,
    :options => ":bucket => 'simple_riak_with_expires', :expires => true",
    # We don't want Riak warnings in tests
    :preamble => "require 'riak'\n\nRiak.disable_list_keys_warnings = true\n\n",
    :specs => EXPIRES_SPECS
  },
  'simple_couch' => {
    :store => :Couch,
    :options => ":db => 'simple_couch'"
  },
  'simple_couch_with_expires' => {
    :store => :Couch,
    :options => ":db => 'simple_couch_with_expires', :expires => true",
    :specs => EXPIRES_SPECS
  },
  'simple_mongo' => {
    :store => :Mongo,
    :options => ":db => 'simple_mongo'"
  },
  'simple_mongo_with_expires' => {
    :store => :Mongo,
    :options => ":db => 'simple_mongo_with_expires', :expires => true",
    :specs => EXPIRES_SPECS
  },
  'simple_null' => {
    :store => :Null,
    :specs => [:null, :marshallable_key, :returndifferent]
  },
  'null_adapter' => {
    :build => 'Moneta::Adapters::Null.new',
    :specs => :null
  },
  'simple_sequel' => {
    :store => :Sequel,
    :options => ':db => (defined?(JRUBY_VERSION) ? "jdbc:sqlite:" : "sqlite:") + File.join(make_tempdir, "simple_sequel")'
  },
  'simple_sequel_with_expires' => {
    :store => :Sequel,
    :options => ':db => (defined?(JRUBY_VERSION) ? "jdbc:sqlite:" : "sqlite:") + File.join(make_tempdir, "simple_sequel_with_expires"), :expires => true',
    :specs => EXPIRES_SPECS
  },
  'simple_datamapper' => {
    :store => :DataMapper,
    :options => ':setup => "sqlite3://#{make_tempdir}/simple_datamapper"',
    # DataMapper needs default repository to be setup
    :preamble => "require 'dm-core'\nDataMapper.setup(:default, :adapter => :in_memory)\n"
  },
  'simple_datamapper_with_expires' => {
    :store => :DataMapper,
    :options => ':setup => "sqlite3://#{make_tempdir}/simple_datamapper_with_expires", :expires => true',
    # DataMapper needs default repository to be setup
    :preamble => "require 'dm-core'\nDataMapper.setup(:default, :adapter => :in_memory)\n",
    :specs => EXPIRES_SPECS
  },
  'simple_datamapper_with_repository' => {
    :store => :DataMapper,
    :options => ':repository => :repo, :setup => "sqlite3://#{make_tempdir}/simple_datamapper_with_repository"',
    # DataMapper needs default repository to be setup
    :preamble => "require 'dm-core'\nDataMapper.setup(:default, :adapter => :in_memory)\n"
  },
  'simple_activerecord' => {
    :store => :ActiveRecord,
    :options => ":connection => { :adapter => (defined?(JRUBY_VERSION) ? 'jdbcsqlite3' : 'sqlite3'), :database => File.join(make_tempdir, 'simple_activerecord') }"
  },
  'simple_activerecord_with_expires' => {
    :store => :ActiveRecord,
    :options => ":connection => { :adapter => (defined?(JRUBY_VERSION) ? 'jdbcsqlite3' : 'sqlite3'), :database => File.join(make_tempdir, 'simple_activerecord_with_expires') }, :expires => true",
    :specs => EXPIRES_SPECS
  },
  'simple_fog' => {
    :store                  => :Fog,
    :options => ":aws_access_key_id => 'fake_access_key_id',
    :aws_secret_access_key  => 'fake_secret_access_key',
    :provider               => 'AWS',
    :dir                    => 'moneta'",
    # Put Fog into testing mode
    :preamble               => "require 'fog'\nFog.mock!\n"
  },
  'simple_fog_with_expires' => {
    :store                  => :Fog,
    :options => ":aws_access_key_id => 'fake_access_key_id',
    :aws_secret_access_key  => 'fake_secret_access_key',
    :provider               => 'AWS',
    :dir                    => 'moneta',
    :expires                => true",
    # Put Fog into testing mode
    :preamble               => "require 'fog'\nFog.mock!\n",
    :specs => EXPIRES_SPECS
  },
  'expires_memory' => {
    :build => %{Moneta.build do
  use :Expires
  adapter :Memory
end},
    :specs => [:null, :store, :expires]
  },
  'expires_file' => {
    :build => %{Moneta.build do
  use :Expires
  use :Transformer, :key => [:marshal, :escape], :value => :marshal
  adapter :File, :dir => File.join(make_tempdir, "expires-file")
end},
    :specs => [:null, :store, :expires, :returndifferent, :marshallable_key],
    :tests => %{
it 'should delete expired value in underlying file storage' do
  store.store('foo', 'bar', :expires => 2)
  store['foo'].should == 'bar'
  sleep 1
  store['foo'].should == 'bar'
  sleep 2
  store['foo'].should == nil
  store.adapter['foo'].should == nil
  store.adapter.adapter['foo'].should == nil
end
}
  },
  'proxy_redis' => {
    :build => %{Moneta.build do
  use :Proxy
  use :Proxy
  adapter :Redis
end},
    :specs => ADAPTER_SPECS + [:expires_stringkey_stringvalue]
  },
  'proxy_expires_memory' => {
    :build => %{Moneta.build do
  use :Proxy
  use :Expires
  use :Proxy
  adapter :Memory
end},
    :specs => [:null, :store, :expires]
  },
  'cache_file_memory' => {
    :build => %{Moneta.build do
  use(:Cache) do
    backend { adapter :File, :dir => File.join(make_tempdir, "cache_file_memory") }
    cache { adapter :Memory }
  end
end},
    :specs => ADAPTER_SPECS,
    :tests => %{
it 'should store loaded values in cache' do
  store.backend['foo'] = 'bar'
  store.cache['foo'].should == nil
  store['foo'].should == 'bar'
  store.cache['foo'].should == 'bar'
  store.backend.delete('foo')
  store['foo'].should == 'bar'
  store.delete('foo')
  store['foo'].should == nil
end
}
  },
  'cache_memory_null' => {
    :build => %{Moneta.build do
  use(:Cache) do
    backend(Moneta::Adapters::Memory.new)
    cache(Moneta::Adapters::Null.new)
  end
end},
    :specs => ADAPTER_SPECS
  },
  'shared' => {
    :build => %{Moneta.build do
  use(:Shared) do
    adapter :Memory
  end
end},
    :specs => ADAPTER_SPECS,
    :tests => %{
it 'should share values' do
  store['shared_key'] = 'shared_value'
  second = new_store
  second.key?('shared_key').should be_true
  second['shared_key'].should == 'shared_value'
  second.close
end
}
  },
  'stack_file_memory' => {
    :build => %{Moneta.build do
  use(:Stack) do
    add(Moneta.new(:Null))
    add(Moneta::Adapters::Null.new)
    add { adapter :File, :dir => File.join(make_tempdir, "stack-file1") }
    add { adapter :Memory }
  end
end},
    :specs => ADAPTER_SPECS
  },
  'stack_memory_file' => {
    :build => %{Moneta.build do
  use(:Stack) do
    add(Moneta.new(:Null))
    add(Moneta::Adapters::Null.new)
    add { adapter :Memory }
    add { adapter :File, :dir => File.join(make_tempdir, "stack-file2") }
  end
end},
    :specs => [:null_stringkey_stringvalue, :store_stringkey_stringvalue]
  },
  'lock' => {
    :build => %{Moneta.build do
  use :Lock
  adapter :Memory
end},
    :specs => [:null, :store]
  },
  'transformer_zlib' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :zlib
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::Zlib::Deflate.deflate('value')
end}
  },
  'transformer_bzip2' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :bzip2
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::Bzip2.compress('value')
end}
  },
  'transformer_lzo' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :lzo
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::LZO.compress('value')
end}
  },
  'transformer_lzma' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :lzma
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::LZMA.compress('value')
end}
  },
  'transformer_snappy' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :snappy
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::Snappy.deflate('value')
end}
  },
  'transformer_quicklz' => {
    :build => %{Moneta.build do
  use :Transformer, :value => :quicklz
  adapter :Memory
end},
    :value => %w(String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::QuickLZ.compress('value')
end}
  },
  'transformer_json' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :json, :value => :json
  adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::MultiJson.dump(['value'])
end}
  },
  'transformer_bert' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :bert, :value => :bert
  adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::BERT.encode('value')
end}
  },
  'transformer_bencode' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :bencode, :value => :bencode
  adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::BEncode.dump('value')
end}
  },
  'transformer_bson' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :bson, :value => :bson
  adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::BSON.serialize('v'=>'value').to_s
end}
  },
  'transformer_ox' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :ox, :value => :ox
  adapter :Memory
end},
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::Ox.dump('value')
end}
  },
  'transformer_tnet' => {
    :build => %{Moneta.build do
 use :Transformer, :key => :tnet, :value => :tnet
 adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::TNetstring.dump('value')
end}
  },
  'transformer_msgpack' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :msgpack, :value => :msgpack
  adapter :Memory
end},
    :key => %w(Hash String),
    :value => %w(Hash String),
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::MessagePack.pack('value')
end}
  },
  'transformer_yaml' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :yaml, :value => :yaml
  adapter :Memory
end},
    :specs => [:null, :store, :returndifferent],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == ::YAML.dump('value')
end}
  },
  'transformer_marshal_hmac' => {
    :build => %{Moneta.build do
  use :Transformer, :key => :marshal, :value => [:marshal, :hmac], :secret => 'secret'
  adapter :Memory
end},
    :specs => [:null, :store, :returndifferent, :marshallable_key, :marshallable_value]
  },
  'transformer_marshal_base64' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :base64], :value => [:marshal, :base64]
  adapter :Memory
end},
    :specs => [:null, :store, :returndifferent, :marshallable_key, :marshallable_value],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == [::Marshal.dump('value')].pack('m').strip
end}
  },
  'transformer_marshal_prefix' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :prefix], :value => :marshal, :prefix => 'moneta'
  adapter :Memory
end},
  },
  'transformer_marshal_uuencode' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :uuencode], :value => [:marshal, :uuencode]
  adapter :Memory
end},
    :specs => [:null, :store, :returndifferent, :marshallable_key, :marshallable_value],
    :tests => %{
it 'should transform value' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == [::Marshal.dump('value')].pack('u').strip
end}
  },
  'transformer_marshal_escape' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :escape], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_md5' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :md5], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_sha1' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :sha1], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_sha256' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :sha256], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_sha384' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :sha384], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_sha512' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :sha512], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_rmd160' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :rmd160], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_md5_spread' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :md5, :spread], :value => :marshal
  adapter :Memory
end},
  },
  'transformer_marshal_truncate' => {
    :build => %{Moneta.build do
  use :Transformer, :key => [:marshal, :truncate], :value => :marshal, :maxlen => 64
  adapter :Memory
end},
  },
  'adapter_activerecord' => {
    :build => "Moneta::Adapters::ActiveRecord.new(:connection => { :adapter => (defined?(JRUBY_VERSION) ? 'jdbcsqlite3' : 'sqlite3'), :database => File.join(make_tempdir, 'adapter_activerecord') })",
    :specs => ADAPTER_SPECS,
    :tests => %{
it 'updates an existing key/value' do
  store['foo/bar'] = '1'
  store['foo/bar'] = '2'
  records = store.table.find :all, :conditions => { :k => 'foo/bar' }
  records.count.should == 1
end

it 'uses an existing connection' do
  ActiveRecord::Base.establish_connection :adapter => (defined?(JRUBY_VERSION) ? 'jdbcsqlite3' : 'sqlite3'), :database => File.join(make_tempdir, 'activerecord-existing')

  store = Moneta::Adapters::ActiveRecord.new
  store.table.should be_table_exists
end
}
  },
  'adapter_client' => {
    :preamble => "$tcp_server ||= Moneta::Server.new(Moneta.new(:Memory))\n",
    :build => "Moneta::Adapters::Client.new",
    :specs => ADAPTER_SPECS
  },
  'adapter_cassandra' => {
    :build => "Moneta::Adapters::Cassandra.new(:keyspace => 'adapter_cassandra')",
    :specs => ADAPTER_SPECS
  },
  'adapter_hbase' => {
    :build => "Moneta::Adapters::HBase.new(:table => 'adapter_hbase')",
    :specs => ADAPTER_SPECS
  },
  'adapter_cookie' => {
    :build => 'Moneta::Adapters::Cookie.new',
    :specs => ADAPTER_SPECS
  },
  'adapter_couch' => {
    :build => "Moneta::Adapters::Couch.new(:db => 'adapter_couch')",
    :specs => ADAPTER_SPECS
  },
  'adapter_datamapper' => {
    :build => 'Moneta::Adapters::DataMapper.new(:setup => "sqlite3://#{make_tempdir}/adapter_datamapper")',
    # DataMapper needs default repository to be setup
    :preamble => "require 'dm-core'\nDataMapper.setup(:default, :adapter => :in_memory)\n",
    :specs => ADAPTER_SPECS,
    :tests => %q{
it 'does not cross contaminate when storing' do
  first = Moneta::Adapters::DataMapper.new(:setup => "sqlite3://#{make_tempdir}/datamapper-first")
  first.clear

  second = Moneta::Adapters::DataMapper.new(:repository => :sample, :setup => "sqlite3://#{make_tempdir}/datamapper-second")
  second.clear

  first['key'] = 'value'
  second['key'] = 'value2'

  first['key'].should == 'value'
  second['key'].should == 'value2'
end

it 'does not cross contaminate when deleting' do
  first = Moneta::Adapters::DataMapper.new(:setup => "sqlite3://#{make_tempdir}/datamapper-first")
  first.clear

  second = Moneta::Adapters::DataMapper.new(:repository => :sample, :setup => "sqlite3://#{make_tempdir}/datamapper-second")
  second.clear

  first['key'] = 'value'
  second['key'] = 'value2'

  first.delete('key').should == 'value'
  first.key?('key').should == false
  second['key'].should == 'value2'
end
}
  },
  'adapter_dbm' => {
    :build => 'Moneta::Adapters::DBM.new(:file => File.join(make_tempdir, "adapter_dbm"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_file' => {
    :build => 'Moneta::Adapters::File.new(:dir => File.join(make_tempdir, "adapter_file"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_fog' => {
    :build => "Moneta::Adapters::Fog.new(:aws_access_key_id => 'fake_access_key_id',
    :aws_secret_access_key  => 'fake_secret_access_key',
    :provider               => 'AWS',
    :dir                    => 'moneta')",
    # Put Fog into testing mode
    :preamble               => "require 'fog'\nFog.mock!\n",
    :specs => ADAPTER_SPECS
  },
  'adapter_gdbm' => {
    :build => 'Moneta::Adapters::GDBM.new(:file => File.join(make_tempdir, "adapter_gdbm"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_localmemcache' => {
    :build => 'Moneta::Adapters::LocalMemCache.new(:file => File.join(make_tempdir, "adapter_localmemcache"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_memcached_dalli' => {
    :build => 'Moneta::Adapters::MemcachedDalli.new(:namespace => "adapter_memcached_dalli")',
    :specs => ADAPTER_SPECS + [:expires_stringkey_stringvalue]
  },
  'adapter_memcached_native' => {
    :build => 'Moneta::Adapters::MemcachedNative.new(:namespace => "adapter_memcached_native")',
    :specs => ADAPTER_SPECS + [:expires_stringkey_stringvalue]
  },
  'adapter_memcached' => {
    :build => 'Moneta::Adapters::Memcached.new(:namespace => "adapter_memcached")',
    :specs => ADAPTER_SPECS + [:expires_stringkey_stringvalue]
  },
  'adapter_memory' => {
    :build => 'Moneta::Adapters::Memory.new',
    :specs => [:null, :store]
  },
  'adapter_lruhash' => {
    :build => 'Moneta::Adapters::LRUHash.new',
    :specs => ADAPTER_SPECS,
    :tests => %{
it 'should delete oldest' do
  store = Moneta::Adapters::LRUHash.new(:max_size => 10)
  store[0]  = 'y'
  (1..1000).each do |i|
    store[i] = 'x'
    store[0].should == 'y'
    store.instance_variable_get(:@entry).size.should == [10, i+1].min
    (0...[9, i-1].min).each do |j|
      store.instance_variable_get(:@entry)[i-j].should_not be_nil
    end
    store.key?(i-9).should be_false if i > 9
  end
end}
  },
  'adapter_mongo' => {
    :build => 'Moneta::Adapters::Mongo.new(:db => "adapter_mongo")',
    :specs => ADAPTER_SPECS
  },
  'adapter_pstore' => {
    :build => 'Moneta::Adapters::PStore.new(:file => File.join(make_tempdir, "adapter_pstore"))',
    :specs => ADAPTER_SPECS + [:null_stringkey_objectvalue,
                               :store_stringkey_objectvalue,
                               :returndifferent_stringkey_objectvalue]
  },
  'adapter_redis' => {
    :build => 'Moneta::Adapters::Redis.new',
    :specs => ADAPTER_SPECS + [:expires_stringkey_stringvalue]
  },
  'adapter_riak' => {
    :build => 'Moneta::Adapters::Riak.new',
    :options => ":bucket => 'adapter_riak'",
    :specs => ADAPTER_SPECS,
    # We don't want Riak warnings in tests
    :preamble => "require 'riak'\n\nRiak.disable_list_keys_warnings = true\n\n"
  },
  'adapter_sdbm' => {
    :build => 'Moneta::Adapters::SDBM.new(:file => File.join(make_tempdir, "adapter_sdbm"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_leveldb' => {
    :build => 'Moneta::Adapters::LevelDB.new(:dir => File.join(make_tempdir, "adapter_leveldb"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_sequel' => {
    :build => 'Moneta::Adapters::Sequel.new(:db => (defined?(JRUBY_VERSION) ? "jdbc:sqlite:" : "sqlite:") + File.join(make_tempdir, "adapter_sequel"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_sqlite' => {
    :build => 'Moneta::Adapters::Sqlite.new(:file => File.join(make_tempdir, "adapter_sqlite"))',
    :specs => ADAPTER_SPECS
  },
  'adapter_tokyocabinet_bdb' => {
    :build => 'Moneta::Adapters::TokyoCabinet.new(:file => File.join(make_tempdir, "adapter_tokyocabinet_bdb"), :type => :bdb)',
    :specs => ADAPTER_SPECS
  },
  'adapter_tokyocabinet_hdb' => {
    :build => 'Moneta::Adapters::TokyoCabinet.new(:file => File.join(make_tempdir, "adapter_tokyocabinet_hdb"), :type => :hdb)',
    :specs => ADAPTER_SPECS
  },
  'adapter_yaml' => {
    :build => 'Moneta::Adapters::YAML.new(:file => File.join(make_tempdir, "adapter_yaml"))',
    :specs => ADAPTER_SPECS + [:null_stringkey_objectvalue,
                               :store_stringkey_objectvalue,
                               :returndifferent_stringkey_objectvalue]
  },
}

SPECS = {}

KEYS = {
  'String' => ['strkey1', 'strkey2'].map(&:inspect),
  'Object' => ['Value.new(:objkey1)', 'Value.new(:objkey2)'],
  'Hash' => [{'hashkey1' => 'hashkey2'}, {'hashkey3' => 'hashkey4'}].map(&:inspect)
}

VALUES = {
  'Boolean' => [true, false],
  'String' => ['strval1', 'strval2'].map(&:inspect),
  'Hash' => [{'hashval1' => ['array1', 1]}, {'hashval3' => ['array2', {'hashval4' => 42}]}].map(&:inspect),
  'Object' => ['Value.new(:objval1)', 'Value.new(:objval2)'],
}

KEYS.each do |key_type, (key1,key2)|
  VALUES.each do |val_type, (val1,val2)|

    code = %{it "reads from keys that are #{key_type}s like a Hash" do
  store[#{key1}].should == nil
  store.load(#{key1}).should == nil
end

it "guarantees that the same #{val_type} value is returned when setting a #{key_type} key" do
  value = #{val1}
  (store[#{key1}] = value).should equal(value)
end

it "returns false from key? if a #{key_type} key is not available" do
  store.key?(#{key1}).should == false
end

it "returns nil from delete if an element for a #{key_type} key does not exist" do
  store.delete(#{key1}).should == nil
end

it "removes all #{key_type} keys from the store with clear" do
  store[#{key1}] = #{val1}
  store[#{key2}] = #{val2}
  store.clear.should equal(store)
  store.key?(#{key1}).should_not ==  true
  store.key?(#{key2}).should_not == true
end

it "fetches a #{key_type} key with a default value with fetch, if the key is not available" do
  store.fetch(#{key1}, #{val1}).should == #{val1}
end

it "fetches a #{key_type} key with a block with fetch, if the key is not available" do
  key = #{key1}
  value = #{val1}
  store.fetch(key) do |k|
    k.should equal(key)
    value
  end.should equal(value)
end

it 'should accept options' do
  store.key?(#{key1}, :option1 => 1).should == false
  store.load(#{key1}, :option2 => 2).should == nil
  store.fetch(#{key1}, 42, :option3 => 3).should == 42
  store.fetch(#{key1}, :option3 => 3) { 42 }.should == 42
  store.delete(#{key1}, :option4 => 4).should == nil
  store.clear(:option5 => 5).should equal(store)
  store.store(#{key1}, #{val1}, :option6 => 6).should == #{val1}
end}
    SPECS["null_#{key_type.downcase}key_#{val_type.downcase}value"] = code

    code = %{it "writes #{val_type} values to keys that are #{key_type}s like a Hash" do
  store[#{key1}] = #{val1}
  store[#{key1}].should == #{val1}
  store.load(#{key1}).should == #{val1}
end

it "returns true from key? if a #{key_type} key is available" do
  store[#{key1}] = #{val1}
  store.key?(#{key1}).should == true
  store[#{key2}] = #{val2}
  store.key?(#{key2}).should == true
end

it "stores #{val_type} values with #{key_type} keys with #store" do
  value = #{val1}
  store.store(#{key1}, value).should equal(value)
  store[#{key1}].should == #{val1}
  store.load(#{key1}).should == #{val1}
end

it "removes and returns a #{val_type} element with a #{key_type} key from the backing store via delete if it exists" do
  store[#{key1}] = #{val1}
  store.delete(#{key1}).should == #{val1}
  store.key?(#{key1}).should == false
end

it "overwrites existing #{val_type} values with #{key_type}" do
  store[#{key1}] = #{val1}
  store[#{key1}].should == #{val1}
  store[#{key1}] = #{val2}
  store[#{key1}].should == #{val2}
end

it "does not run the block if the #{key_type} key is available" do
  store[#{key1}] = #{val1}
  unaltered = "unaltered"
  store.fetch(#{key1}) { unaltered = "altered" }
  unaltered.should == "unaltered"
end

it "fetches a #{key_type} key with a default value with fetch, if the key is available" do
  store[#{key1}] = #{val1}
  store.fetch(#{key1}, #{val2}).should == #{val1}
end}
    SPECS["store_#{key_type.downcase}key_#{val_type.downcase}value"] = code

    code = %{it "guarantees that a different #{val_type} value is retrieved from the #{key_type} key" do
  value = #{val1}
  store[#{key1}] = #{val1}
  store[#{key1}].should_not be_equal(#{val1})
end}
    if val_type != 'Boolean'
      SPECS["returndifferent_#{key_type.downcase}key_#{val_type.downcase}value"] = code
    end

    code = %{it 'should support expires on store and #[]' do
  store.store(#{key1}, #{val1}, :expires => 2)
  store[#{key1}].should == #{val1}
  sleep 1
  store[#{key1}].should == #{val1}
  sleep 2
  store[#{key1}].should == nil
end

it 'should support expires on store and load' do
  store.store(#{key1}, #{val1}, :expires => 2)
  store.load(#{key1}).should == #{val1}
  sleep 1
  store.load(#{key1}).should == #{val1}
  sleep 2
  store.load(#{key1}).should == nil
end

it 'should support expires on store and key?' do
  store.store(#{key1}, #{val1}, :expires => 2)
  store.key?(#{key1}).should == true
  sleep 1
  store.key?(#{key1}).should == true
  sleep 2
  store.key?(#{key1}).should == false
end

it 'should support updating the expiration time in load' do
  store.store(#{key2}, #{val2}, :expires => 2)
  store[#{key2}].should == #{val2}
  sleep 1
  store.load(#{key2}, :expires => 3).should == #{val2}
  store[#{key2}].should == #{val2}
  sleep 1
  store[#{key2}].should == #{val2}
  sleep 3
  store[#{key2}].should == nil
end

it 'should support updating the expiration time in key?' do
  store.store(#{key2}, #{val2}, :expires => 2)
  store[#{key2}].should == #{val2}
  sleep 1
  store.key?(#{key2}, :expires => 3).should be_true
  store[#{key2}].should == #{val2}
  sleep 1
  store[#{key2}].should == #{val2}
  sleep 3
  store[#{key2}].should == nil
end

it 'should support updating the expiration time in fetch' do
  store.store(#{key1}, #{val1}, :expires => 2)
  store[#{key1}].should == #{val1}
  sleep 1
  store.fetch(#{key1}, nil, :expires => 3).should == #{val1}
  store[#{key1}].should == #{val1}
  sleep 1
  store[#{key1}].should == #{val1}
  sleep 3
  store[#{key1}].should == nil
end

it 'should respect expires in delete' do
  store.store(#{key2}, #{val2}, :expires => 2)
  store[#{key2}].should == #{val2}
  sleep 1
  store[#{key2}].should == #{val2}
  sleep 2
  store.delete(#{key2}).should == nil
end}
    SPECS["expires_#{key_type.downcase}key_#{val_type.downcase}value"] = code

  end
end

SPECS['marshallable_key']  = %{it 'refuses to #[] from keys that cannot be marshalled' do
  expect do
    store[Struct.new(:foo).new(:bar)]
  end.to raise_error(marshal_error)
end

it 'refuses to load from keys that cannot be marshalled' do
  expect do
    store.load(Struct.new(:foo).new(:bar))
  end.to raise_error(marshal_error)
end

it 'refuses to fetch from keys that cannot be marshalled' do
  expect do
    store.fetch(Struct.new(:foo).new(:bar), true)
  end.to raise_error(marshal_error)
end

it 'refuses to #[]= to keys that cannot be marshalled' do
  expect do
    store[Struct.new(:foo).new(:bar)] = 'value'
  end.to raise_error(marshal_error)
end

it 'refuses to store to keys that cannot be marshalled' do
  expect do
    store.store Struct.new(:foo).new(:bar), 'value'
  end.to raise_error(marshal_error)
end

it 'refuses to check for key? if the key cannot be marshalled' do
  expect do
    store.key? Struct.new(:foo).new(:bar)
  end.to raise_error(marshal_error)
end

it 'refuses to delete a key if the key cannot be marshalled' do
  expect do
    store.delete Struct.new(:foo).new(:bar)
  end.to raise_error(marshal_error)
end}

SPECS['marshallable_value']  = %{it 'refuses to store values that cannot be marshalled' do
  expect do
    store.store 'key', Struct.new(:foo).new(:bar)
  end.to raise_error(marshal_error)
end}

SPECS['bypass_transformer']  = %{it 'allows to bypass transformer with :raw' do
  store['key'] = 'value'
  store.load('key', :raw => true).should == Marshal.dump('value')
  store.store('key', 'value', :raw => true)
  store.load('key', :raw => true).should == 'value'
  expect do
    store['key']
  end.to raise_error(Exception)
end}

specs_code = "#{header}\n"
SPECS.each do |key, code|
  specs_code << "#################### #{key} ####################\n\n" <<
    "shared_examples_for '#{key}' do\n  " << code.gsub("\n", "\n  ") << "\nend\n\n"
end
specs_code.gsub!(/\n +\n/, "\n\n")
File.open(File.join(File.dirname(__FILE__), 'monetaspecs.rb'), 'w') {|out| out << specs_code }

TESTS.each do |name, options|
  build = options.delete(:build)
  store = options.delete(:store)
  key = [options.delete(:key) || %w(Object String Hash)].flatten
  value = [options.delete(:value) || %w(Object String Hash Boolean)].flatten

  specs = [options.delete(:specs) || SIMPLE_SPECS].flatten
  specs_code = []
  specs.each do |s|
    specs_code << "  it_should_behave_like '#{s}'" if SPECS[s.to_s]
    key.each do |k|
      value.each do |v|
        x = "#{s}_#{k.downcase}key_#{v.downcase}value"
        specs_code << "  it_should_behave_like '#{x}'" if SPECS[x]
      end
    end
  end

  preamble = options.delete(:preamble).to_s.gsub("\n", "\n  ")
  opts = options.delete(:options)
  opts = ', ' << opts if opts

  build ||= "Moneta.new(#{store.inspect}#{opts}, :logger => {:out => File.open(File.join(make_tempdir, '#{name}.log'), 'a')})"

  code = %{#{header}require 'helper'

describe_moneta #{name.inspect} do
  #{preamble}def new_store
    #{build.gsub("\n", "\n    ")}
  end

  include_context 'setup_store'
#{specs_code.join("\n")}#{options[:tests].to_s.gsub("\n", "\n  ")}
end
}

  code.gsub!(/\n +\n/, "\n\n")
  File.open(File.join(File.dirname(__FILE__), 'moneta', "#{name}_spec.rb"), 'w') {|out| out << code }
end
