# Generated by generate.rb

#################### null_nilkey_nilvalue ####################

shared_examples_for 'null_nilkey_nilvalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same Nil value is returned when setting a Nil key" do
    value = 0
    (store[0] = value).should equal(value)

    value = nil
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = 0
    store[nil] = nil
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, 0).should == 0
    store.fetch(nil, nil).should == nil
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, 0, :option6 => 6).should == 0
  end
end

#################### store_nilkey_nilvalue ####################

shared_examples_for 'store_nilkey_nilvalue' do
  it "writes Nil values to keys that are Nils like a Hash" do
    store[0] = 0
    store[0].should == 0
    store.load(0).should == 0

    store[nil] = nil
    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = 0
    store.key?(0).should == true
    store[nil] = nil
    store.key?(nil).should == true
  end

  it "stores Nil values with Nil keys with #store" do
    value = 0
    store.store(0, value).should equal(value)
    store[0].should == 0
    store.load(0).should == 0

    value = nil
    store.store(nil, value).should equal(value)
    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "stores Nil after clear" do
    store[0] = 0
    store[nil] = nil
    store.clear.should equal(store)
    store[0] = 0
    store[0].should == 0
    store[nil].should be_nil
  end

  it "removes and returns a Nil element with a Nil key from the backing store via delete if it exists" do
    store[0] = 0
    store.delete(0).should == 0
    store.key?(0).should == false

    store[nil] = nil
    store.delete(nil).should == nil
    store.key?(nil).should == false
  end

  it "overwrites existing Nil values with Nil" do
    store[0] = 0
    store[0].should == 0
    store[0] = nil
    store[0].should == nil
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = 0
    store.fetch(0, nil).should == 0
  end
end

#################### persist_nilkey_nilvalue ####################

shared_examples_for 'persist_nilkey_nilvalue' do
  it "persists Nil values with Nil keys" do
    store[0] = 0
    store[nil] = nil
    store.close

    store = new_store
    store[0].should == 0
    store[nil].should == nil
  end
end

#################### null_nilkey_integervalue ####################

shared_examples_for 'null_nilkey_integervalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same Integer value is returned when setting a Nil key" do
    value = -10
    (store[0] = value).should equal(value)

    value = 42
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = -10
    store[nil] = 42
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, -10).should == -10
    store.fetch(nil, 42).should == 42
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, -10, :option6 => 6).should == -10
  end
end

#################### store_nilkey_integervalue ####################

shared_examples_for 'store_nilkey_integervalue' do
  it "writes Integer values to keys that are Nils like a Hash" do
    store[0] = -10
    store[0].should == -10
    store.load(0).should == -10

    store[nil] = 42
    store[nil].should == 42
    store.load(nil).should == 42
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = -10
    store.key?(0).should == true
    store[nil] = 42
    store.key?(nil).should == true
  end

  it "stores Integer values with Nil keys with #store" do
    value = -10
    store.store(0, value).should equal(value)
    store[0].should == -10
    store.load(0).should == -10

    value = 42
    store.store(nil, value).should equal(value)
    store[nil].should == 42
    store.load(nil).should == 42
  end

  it "stores Nil after clear" do
    store[0] = -10
    store[nil] = 42
    store.clear.should equal(store)
    store[0] = -10
    store[0].should == -10
    store[nil].should be_nil
  end

  it "removes and returns a Integer element with a Nil key from the backing store via delete if it exists" do
    store[0] = -10
    store.delete(0).should == -10
    store.key?(0).should == false

    store[nil] = 42
    store.delete(nil).should == 42
    store.key?(nil).should == false
  end

  it "overwrites existing Integer values with Nil" do
    store[0] = -10
    store[0].should == -10
    store[0] = 42
    store[0].should == 42
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = -10
    store.fetch(0, 42).should == -10
  end
  it "does not run the block if the Nil key is available" do
    store[0] = -10
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[nil] = 42
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_nilkey_integervalue ####################

shared_examples_for 'persist_nilkey_integervalue' do
  it "persists Integer values with Nil keys" do
    store[0] = -10
    store[nil] = 42
    store.close

    store = new_store
    store[0].should == -10
    store[nil].should == 42
  end
end

#################### null_nilkey_booleanvalue ####################

shared_examples_for 'null_nilkey_booleanvalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a Nil key" do
    value = true
    (store[0] = value).should equal(value)

    value = false
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = true
    store[nil] = false
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, true).should == true
    store.fetch(nil, false).should == false
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, true, :option6 => 6).should == true
  end
end

#################### store_nilkey_booleanvalue ####################

shared_examples_for 'store_nilkey_booleanvalue' do
  it "writes Boolean values to keys that are Nils like a Hash" do
    store[0] = true
    store[0].should == true
    store.load(0).should == true

    store[nil] = false
    store[nil].should == false
    store.load(nil).should == false
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = true
    store.key?(0).should == true
    store[nil] = false
    store.key?(nil).should == true
  end

  it "stores Boolean values with Nil keys with #store" do
    value = true
    store.store(0, value).should equal(value)
    store[0].should == true
    store.load(0).should == true

    value = false
    store.store(nil, value).should equal(value)
    store[nil].should == false
    store.load(nil).should == false
  end

  it "stores Nil after clear" do
    store[0] = true
    store[nil] = false
    store.clear.should equal(store)
    store[0] = true
    store[0].should == true
    store[nil].should be_nil
  end

  it "removes and returns a Boolean element with a Nil key from the backing store via delete if it exists" do
    store[0] = true
    store.delete(0).should == true
    store.key?(0).should == false

    store[nil] = false
    store.delete(nil).should == false
    store.key?(nil).should == false
  end

  it "overwrites existing Boolean values with Nil" do
    store[0] = true
    store[0].should == true
    store[0] = false
    store[0].should == false
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = true
    store.fetch(0, false).should == true
  end
  it "does not run the block if the Nil key is available" do
    store[0] = true
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[nil] = false
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_nilkey_booleanvalue ####################

shared_examples_for 'persist_nilkey_booleanvalue' do
  it "persists Boolean values with Nil keys" do
    store[0] = true
    store[nil] = false
    store.close

    store = new_store
    store[0].should == true
    store[nil].should == false
  end
end

#################### null_nilkey_stringvalue ####################

shared_examples_for 'null_nilkey_stringvalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same String value is returned when setting a Nil key" do
    value = "strval1"
    (store[0] = value).should equal(value)

    value = "strval2"
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = "strval1"
    store[nil] = "strval2"
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, "strval1").should == "strval1"
    store.fetch(nil, "strval2").should == "strval2"
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_nilkey_stringvalue ####################

shared_examples_for 'store_nilkey_stringvalue' do
  it "writes String values to keys that are Nils like a Hash" do
    store[0] = "strval1"
    store[0].should == "strval1"
    store.load(0).should == "strval1"

    store[nil] = "strval2"
    store[nil].should == "strval2"
    store.load(nil).should == "strval2"
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = "strval1"
    store.key?(0).should == true
    store[nil] = "strval2"
    store.key?(nil).should == true
  end

  it "stores String values with Nil keys with #store" do
    value = "strval1"
    store.store(0, value).should equal(value)
    store[0].should == "strval1"
    store.load(0).should == "strval1"

    value = "strval2"
    store.store(nil, value).should equal(value)
    store[nil].should == "strval2"
    store.load(nil).should == "strval2"
  end

  it "stores Nil after clear" do
    store[0] = "strval1"
    store[nil] = "strval2"
    store.clear.should equal(store)
    store[0] = "strval1"
    store[0].should == "strval1"
    store[nil].should be_nil
  end

  it "removes and returns a String element with a Nil key from the backing store via delete if it exists" do
    store[0] = "strval1"
    store.delete(0).should == "strval1"
    store.key?(0).should == false

    store[nil] = "strval2"
    store.delete(nil).should == "strval2"
    store.key?(nil).should == false
  end

  it "overwrites existing String values with Nil" do
    store[0] = "strval1"
    store[0].should == "strval1"
    store[0] = "strval2"
    store[0].should == "strval2"
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = "strval1"
    store.fetch(0, "strval2").should == "strval1"
  end
  it "does not run the block if the Nil key is available" do
    store[0] = "strval1"
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[nil] = "strval2"
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_stringvalue ####################

shared_examples_for 'returndifferent_nilkey_stringvalue' do
  it "guarantees that a different String value is retrieved from the Nil key" do
    value = "strval1"
    store[0] = "strval1"
    store[0].should_not be_equal("strval1")

    value = "strval2"
    store[nil] = "strval2"
    store[nil].should_not be_equal("strval2")
  end
end

#################### persist_nilkey_stringvalue ####################

shared_examples_for 'persist_nilkey_stringvalue' do
  it "persists String values with Nil keys" do
    store[0] = "strval1"
    store[nil] = "strval2"
    store.close

    store = new_store
    store[0].should == "strval1"
    store[nil].should == "strval2"
  end
end

#################### null_nilkey_hashvalue ####################

shared_examples_for 'null_nilkey_hashvalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same Hash value is returned when setting a Nil key" do
    value = {"hashval1"=>["array1", 1]}
    (store[0] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch(nil, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_nilkey_hashvalue ####################

shared_examples_for 'store_nilkey_hashvalue' do
  it "writes Hash values to keys that are Nils like a Hash" do
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store.load(0).should == {"hashval1"=>["array1", 1]}

    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = {"hashval1"=>["array1", 1]}
    store.key?(0).should == true
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(nil).should == true
  end

  it "stores Hash values with Nil keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store(0, value).should equal(value)
    store[0].should == {"hashval1"=>["array1", 1]}
    store.load(0).should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(nil, value).should equal(value)
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores Nil after clear" do
    store[0] = {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store[nil].should be_nil
  end

  it "removes and returns a Hash element with a Nil key from the backing store via delete if it exists" do
    store[0] = {"hashval1"=>["array1", 1]}
    store.delete(0).should == {"hashval1"=>["array1", 1]}
    store.key?(0).should == false

    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(nil).should == false
  end

  it "overwrites existing Hash values with Nil" do
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = {"hashval1"=>["array1", 1]}
    store.fetch(0, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the Nil key is available" do
    store[0] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_hashvalue ####################

shared_examples_for 'returndifferent_nilkey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the Nil key" do
    value = {"hashval1"=>["array1", 1]}
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_nilkey_hashvalue ####################

shared_examples_for 'persist_nilkey_hashvalue' do
  it "persists Hash values with Nil keys" do
    store[0] = {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store[0].should == {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_nilkey_objectvalue ####################

shared_examples_for 'null_nilkey_objectvalue' do
  it "reads from keys that are Nils like a Hash" do
    store[0].should == nil
    store.load(0).should == nil

    store[nil].should == nil
    store.load(nil).should == nil
  end

  it "guarantees that the same Object value is returned when setting a Nil key" do
    value = Value.new(:objval1)
    (store[0] = value).should equal(value)

    value = Value.new(:objval2)
    (store[nil] = value).should equal(value)
  end

  it "returns false from key? if a Nil key is not available" do
    store.key?(0).should == false
    store.key?(nil).should == false
  end

  it "returns nil from delete if an element for a Nil key does not exist" do
    store.delete(0).should == nil
    store.delete(nil).should == nil
  end

  it "removes all Nil keys from the store with clear" do
    store[0] = Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(0).should_not ==  true
    store.key?(nil).should_not == true
  end

  it "fetches a Nil key with a default value with fetch, if the key is not available" do
    store.fetch(0, Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch(nil, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a Nil key with a block with fetch, if the key is not available" do
    key = 0
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = nil
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(0, :option1 => 1).should == false
    store.load(0, :option2 => 2).should == nil
    store.fetch(0, 42, :option3 => 3).should == 42
    store.fetch(0, :option3 => 3) { 42 }.should == 42
    store.delete(0, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(0, Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_nilkey_objectvalue ####################

shared_examples_for 'store_nilkey_objectvalue' do
  it "writes Object values to keys that are Nils like a Hash" do
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store.load(0).should == Value.new(:objval1)

    store[nil] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
    store.load(nil).should == Value.new(:objval2)
  end

  it "returns true from key? if a Nil key is available" do
    store[0] = Value.new(:objval1)
    store.key?(0).should == true
    store[nil] = Value.new(:objval2)
    store.key?(nil).should == true
  end

  it "stores Object values with Nil keys with #store" do
    value = Value.new(:objval1)
    store.store(0, value).should equal(value)
    store[0].should == Value.new(:objval1)
    store.load(0).should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store(nil, value).should equal(value)
    store[nil].should == Value.new(:objval2)
    store.load(nil).should == Value.new(:objval2)
  end

  it "stores Nil after clear" do
    store[0] = Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store.clear.should equal(store)
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store[nil].should be_nil
  end

  it "removes and returns a Object element with a Nil key from the backing store via delete if it exists" do
    store[0] = Value.new(:objval1)
    store.delete(0).should == Value.new(:objval1)
    store.key?(0).should == false

    store[nil] = Value.new(:objval2)
    store.delete(nil).should == Value.new(:objval2)
    store.key?(nil).should == false
  end

  it "overwrites existing Object values with Nil" do
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store[0] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
  end

  it "fetches a Nil key with a default value with fetch, if the key is available" do
    store[0] = Value.new(:objval1)
    store.fetch(0, Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the Nil key is available" do
    store[0] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[nil] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_objectvalue ####################

shared_examples_for 'returndifferent_nilkey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the Nil key" do
    value = Value.new(:objval1)
    store[0] = Value.new(:objval1)
    store[0].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store[nil] = Value.new(:objval2)
    store[nil].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_nilkey_objectvalue ####################

shared_examples_for 'persist_nilkey_objectvalue' do
  it "persists Object values with Nil keys" do
    store[0] = Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store.close

    store = new_store
    store[0].should == Value.new(:objval1)
    store[nil].should == Value.new(:objval2)
  end
end

#################### null_integerkey_nilvalue ####################

shared_examples_for 'null_integerkey_nilvalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same Nil value is returned when setting a Integer key" do
    value = 0
    (store[-10] = value).should equal(value)

    value = nil
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = 0
    store[42] = nil
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, 0).should == 0
    store.fetch(42, nil).should == nil
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, 0, :option6 => 6).should == 0
  end
end

#################### store_integerkey_nilvalue ####################

shared_examples_for 'store_integerkey_nilvalue' do
  it "writes Nil values to keys that are Integers like a Hash" do
    store[-10] = 0
    store[-10].should == 0
    store.load(-10).should == 0

    store[42] = nil
    store[42].should == nil
    store.load(42).should == nil
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = 0
    store.key?(-10).should == true
    store[42] = nil
    store.key?(42).should == true
  end

  it "stores Nil values with Integer keys with #store" do
    value = 0
    store.store(-10, value).should equal(value)
    store[-10].should == 0
    store.load(-10).should == 0

    value = nil
    store.store(42, value).should equal(value)
    store[42].should == nil
    store.load(42).should == nil
  end

  it "stores Integer after clear" do
    store[-10] = 0
    store[42] = nil
    store.clear.should equal(store)
    store[-10] = 0
    store[-10].should == 0
    store[42].should be_nil
  end

  it "removes and returns a Nil element with a Integer key from the backing store via delete if it exists" do
    store[-10] = 0
    store.delete(-10).should == 0
    store.key?(-10).should == false

    store[42] = nil
    store.delete(42).should == nil
    store.key?(42).should == false
  end

  it "overwrites existing Nil values with Integer" do
    store[-10] = 0
    store[-10].should == 0
    store[-10] = nil
    store[-10].should == nil
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = 0
    store.fetch(-10, nil).should == 0
  end
end

#################### persist_integerkey_nilvalue ####################

shared_examples_for 'persist_integerkey_nilvalue' do
  it "persists Nil values with Integer keys" do
    store[-10] = 0
    store[42] = nil
    store.close

    store = new_store
    store[-10].should == 0
    store[42].should == nil
  end
end

#################### null_integerkey_integervalue ####################

shared_examples_for 'null_integerkey_integervalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same Integer value is returned when setting a Integer key" do
    value = -10
    (store[-10] = value).should equal(value)

    value = 42
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = -10
    store[42] = 42
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, -10).should == -10
    store.fetch(42, 42).should == 42
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, -10, :option6 => 6).should == -10
  end
end

#################### store_integerkey_integervalue ####################

shared_examples_for 'store_integerkey_integervalue' do
  it "writes Integer values to keys that are Integers like a Hash" do
    store[-10] = -10
    store[-10].should == -10
    store.load(-10).should == -10

    store[42] = 42
    store[42].should == 42
    store.load(42).should == 42
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = -10
    store.key?(-10).should == true
    store[42] = 42
    store.key?(42).should == true
  end

  it "stores Integer values with Integer keys with #store" do
    value = -10
    store.store(-10, value).should equal(value)
    store[-10].should == -10
    store.load(-10).should == -10

    value = 42
    store.store(42, value).should equal(value)
    store[42].should == 42
    store.load(42).should == 42
  end

  it "stores Integer after clear" do
    store[-10] = -10
    store[42] = 42
    store.clear.should equal(store)
    store[-10] = -10
    store[-10].should == -10
    store[42].should be_nil
  end

  it "removes and returns a Integer element with a Integer key from the backing store via delete if it exists" do
    store[-10] = -10
    store.delete(-10).should == -10
    store.key?(-10).should == false

    store[42] = 42
    store.delete(42).should == 42
    store.key?(42).should == false
  end

  it "overwrites existing Integer values with Integer" do
    store[-10] = -10
    store[-10].should == -10
    store[-10] = 42
    store[-10].should == 42
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = -10
    store.fetch(-10, 42).should == -10
  end
  it "does not run the block if the Integer key is available" do
    store[-10] = -10
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[42] = 42
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_integerkey_integervalue ####################

shared_examples_for 'persist_integerkey_integervalue' do
  it "persists Integer values with Integer keys" do
    store[-10] = -10
    store[42] = 42
    store.close

    store = new_store
    store[-10].should == -10
    store[42].should == 42
  end
end

#################### null_integerkey_booleanvalue ####################

shared_examples_for 'null_integerkey_booleanvalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a Integer key" do
    value = true
    (store[-10] = value).should equal(value)

    value = false
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = true
    store[42] = false
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, true).should == true
    store.fetch(42, false).should == false
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, true, :option6 => 6).should == true
  end
end

#################### store_integerkey_booleanvalue ####################

shared_examples_for 'store_integerkey_booleanvalue' do
  it "writes Boolean values to keys that are Integers like a Hash" do
    store[-10] = true
    store[-10].should == true
    store.load(-10).should == true

    store[42] = false
    store[42].should == false
    store.load(42).should == false
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = true
    store.key?(-10).should == true
    store[42] = false
    store.key?(42).should == true
  end

  it "stores Boolean values with Integer keys with #store" do
    value = true
    store.store(-10, value).should equal(value)
    store[-10].should == true
    store.load(-10).should == true

    value = false
    store.store(42, value).should equal(value)
    store[42].should == false
    store.load(42).should == false
  end

  it "stores Integer after clear" do
    store[-10] = true
    store[42] = false
    store.clear.should equal(store)
    store[-10] = true
    store[-10].should == true
    store[42].should be_nil
  end

  it "removes and returns a Boolean element with a Integer key from the backing store via delete if it exists" do
    store[-10] = true
    store.delete(-10).should == true
    store.key?(-10).should == false

    store[42] = false
    store.delete(42).should == false
    store.key?(42).should == false
  end

  it "overwrites existing Boolean values with Integer" do
    store[-10] = true
    store[-10].should == true
    store[-10] = false
    store[-10].should == false
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = true
    store.fetch(-10, false).should == true
  end
  it "does not run the block if the Integer key is available" do
    store[-10] = true
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[42] = false
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_integerkey_booleanvalue ####################

shared_examples_for 'persist_integerkey_booleanvalue' do
  it "persists Boolean values with Integer keys" do
    store[-10] = true
    store[42] = false
    store.close

    store = new_store
    store[-10].should == true
    store[42].should == false
  end
end

#################### null_integerkey_stringvalue ####################

shared_examples_for 'null_integerkey_stringvalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same String value is returned when setting a Integer key" do
    value = "strval1"
    (store[-10] = value).should equal(value)

    value = "strval2"
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = "strval1"
    store[42] = "strval2"
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, "strval1").should == "strval1"
    store.fetch(42, "strval2").should == "strval2"
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_integerkey_stringvalue ####################

shared_examples_for 'store_integerkey_stringvalue' do
  it "writes String values to keys that are Integers like a Hash" do
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store.load(-10).should == "strval1"

    store[42] = "strval2"
    store[42].should == "strval2"
    store.load(42).should == "strval2"
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = "strval1"
    store.key?(-10).should == true
    store[42] = "strval2"
    store.key?(42).should == true
  end

  it "stores String values with Integer keys with #store" do
    value = "strval1"
    store.store(-10, value).should equal(value)
    store[-10].should == "strval1"
    store.load(-10).should == "strval1"

    value = "strval2"
    store.store(42, value).should equal(value)
    store[42].should == "strval2"
    store.load(42).should == "strval2"
  end

  it "stores Integer after clear" do
    store[-10] = "strval1"
    store[42] = "strval2"
    store.clear.should equal(store)
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store[42].should be_nil
  end

  it "removes and returns a String element with a Integer key from the backing store via delete if it exists" do
    store[-10] = "strval1"
    store.delete(-10).should == "strval1"
    store.key?(-10).should == false

    store[42] = "strval2"
    store.delete(42).should == "strval2"
    store.key?(42).should == false
  end

  it "overwrites existing String values with Integer" do
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store[-10] = "strval2"
    store[-10].should == "strval2"
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = "strval1"
    store.fetch(-10, "strval2").should == "strval1"
  end
  it "does not run the block if the Integer key is available" do
    store[-10] = "strval1"
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[42] = "strval2"
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_stringvalue ####################

shared_examples_for 'returndifferent_integerkey_stringvalue' do
  it "guarantees that a different String value is retrieved from the Integer key" do
    value = "strval1"
    store[-10] = "strval1"
    store[-10].should_not be_equal("strval1")

    value = "strval2"
    store[42] = "strval2"
    store[42].should_not be_equal("strval2")
  end
end

#################### persist_integerkey_stringvalue ####################

shared_examples_for 'persist_integerkey_stringvalue' do
  it "persists String values with Integer keys" do
    store[-10] = "strval1"
    store[42] = "strval2"
    store.close

    store = new_store
    store[-10].should == "strval1"
    store[42].should == "strval2"
  end
end

#################### null_integerkey_hashvalue ####################

shared_examples_for 'null_integerkey_hashvalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same Hash value is returned when setting a Integer key" do
    value = {"hashval1"=>["array1", 1]}
    (store[-10] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch(42, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_integerkey_hashvalue ####################

shared_examples_for 'store_integerkey_hashvalue' do
  it "writes Hash values to keys that are Integers like a Hash" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store.load(-10).should == {"hashval1"=>["array1", 1]}

    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.key?(-10).should == true
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(42).should == true
  end

  it "stores Hash values with Integer keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store(-10, value).should equal(value)
    store[-10].should == {"hashval1"=>["array1", 1]}
    store.load(-10).should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(42, value).should equal(value)
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores Integer after clear" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store[42].should be_nil
  end

  it "removes and returns a Hash element with a Integer key from the backing store via delete if it exists" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.delete(-10).should == {"hashval1"=>["array1", 1]}
    store.key?(-10).should == false

    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(42).should == false
  end

  it "overwrites existing Hash values with Integer" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.fetch(-10, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the Integer key is available" do
    store[-10] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_hashvalue ####################

shared_examples_for 'returndifferent_integerkey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the Integer key" do
    value = {"hashval1"=>["array1", 1]}
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_integerkey_hashvalue ####################

shared_examples_for 'persist_integerkey_hashvalue' do
  it "persists Hash values with Integer keys" do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store[-10].should == {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_integerkey_objectvalue ####################

shared_examples_for 'null_integerkey_objectvalue' do
  it "reads from keys that are Integers like a Hash" do
    store[-10].should == nil
    store.load(-10).should == nil

    store[42].should == nil
    store.load(42).should == nil
  end

  it "guarantees that the same Object value is returned when setting a Integer key" do
    value = Value.new(:objval1)
    (store[-10] = value).should equal(value)

    value = Value.new(:objval2)
    (store[42] = value).should equal(value)
  end

  it "returns false from key? if a Integer key is not available" do
    store.key?(-10).should == false
    store.key?(42).should == false
  end

  it "returns nil from delete if an element for a Integer key does not exist" do
    store.delete(-10).should == nil
    store.delete(42).should == nil
  end

  it "removes all Integer keys from the store with clear" do
    store[-10] = Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(-10).should_not ==  true
    store.key?(42).should_not == true
  end

  it "fetches a Integer key with a default value with fetch, if the key is not available" do
    store.fetch(-10, Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch(42, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a Integer key with a block with fetch, if the key is not available" do
    key = -10
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = 42
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(-10, :option1 => 1).should == false
    store.load(-10, :option2 => 2).should == nil
    store.fetch(-10, 42, :option3 => 3).should == 42
    store.fetch(-10, :option3 => 3) { 42 }.should == 42
    store.delete(-10, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(-10, Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_integerkey_objectvalue ####################

shared_examples_for 'store_integerkey_objectvalue' do
  it "writes Object values to keys that are Integers like a Hash" do
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store.load(-10).should == Value.new(:objval1)

    store[42] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
    store.load(42).should == Value.new(:objval2)
  end

  it "returns true from key? if a Integer key is available" do
    store[-10] = Value.new(:objval1)
    store.key?(-10).should == true
    store[42] = Value.new(:objval2)
    store.key?(42).should == true
  end

  it "stores Object values with Integer keys with #store" do
    value = Value.new(:objval1)
    store.store(-10, value).should equal(value)
    store[-10].should == Value.new(:objval1)
    store.load(-10).should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store(42, value).should equal(value)
    store[42].should == Value.new(:objval2)
    store.load(42).should == Value.new(:objval2)
  end

  it "stores Integer after clear" do
    store[-10] = Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store.clear.should equal(store)
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store[42].should be_nil
  end

  it "removes and returns a Object element with a Integer key from the backing store via delete if it exists" do
    store[-10] = Value.new(:objval1)
    store.delete(-10).should == Value.new(:objval1)
    store.key?(-10).should == false

    store[42] = Value.new(:objval2)
    store.delete(42).should == Value.new(:objval2)
    store.key?(42).should == false
  end

  it "overwrites existing Object values with Integer" do
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store[-10] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
  end

  it "fetches a Integer key with a default value with fetch, if the key is available" do
    store[-10] = Value.new(:objval1)
    store.fetch(-10, Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the Integer key is available" do
    store[-10] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[42] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_objectvalue ####################

shared_examples_for 'returndifferent_integerkey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the Integer key" do
    value = Value.new(:objval1)
    store[-10] = Value.new(:objval1)
    store[-10].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store[42] = Value.new(:objval2)
    store[42].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_integerkey_objectvalue ####################

shared_examples_for 'persist_integerkey_objectvalue' do
  it "persists Object values with Integer keys" do
    store[-10] = Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store.close

    store = new_store
    store[-10].should == Value.new(:objval1)
    store[42].should == Value.new(:objval2)
  end
end

#################### null_booleankey_nilvalue ####################

shared_examples_for 'null_booleankey_nilvalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same Nil value is returned when setting a Boolean key" do
    value = 0
    (store[true] = value).should equal(value)

    value = nil
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = 0
    store[false] = nil
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, 0).should == 0
    store.fetch(false, nil).should == nil
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, 0, :option6 => 6).should == 0
  end
end

#################### store_booleankey_nilvalue ####################

shared_examples_for 'store_booleankey_nilvalue' do
  it "writes Nil values to keys that are Booleans like a Hash" do
    store[true] = 0
    store[true].should == 0
    store.load(true).should == 0

    store[false] = nil
    store[false].should == nil
    store.load(false).should == nil
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = 0
    store.key?(true).should == true
    store[false] = nil
    store.key?(false).should == true
  end

  it "stores Nil values with Boolean keys with #store" do
    value = 0
    store.store(true, value).should equal(value)
    store[true].should == 0
    store.load(true).should == 0

    value = nil
    store.store(false, value).should equal(value)
    store[false].should == nil
    store.load(false).should == nil
  end

  it "stores Boolean after clear" do
    store[true] = 0
    store[false] = nil
    store.clear.should equal(store)
    store[true] = 0
    store[true].should == 0
    store[false].should be_nil
  end

  it "removes and returns a Nil element with a Boolean key from the backing store via delete if it exists" do
    store[true] = 0
    store.delete(true).should == 0
    store.key?(true).should == false

    store[false] = nil
    store.delete(false).should == nil
    store.key?(false).should == false
  end

  it "overwrites existing Nil values with Boolean" do
    store[true] = 0
    store[true].should == 0
    store[true] = nil
    store[true].should == nil
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = 0
    store.fetch(true, nil).should == 0
  end
end

#################### persist_booleankey_nilvalue ####################

shared_examples_for 'persist_booleankey_nilvalue' do
  it "persists Nil values with Boolean keys" do
    store[true] = 0
    store[false] = nil
    store.close

    store = new_store
    store[true].should == 0
    store[false].should == nil
  end
end

#################### null_booleankey_integervalue ####################

shared_examples_for 'null_booleankey_integervalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same Integer value is returned when setting a Boolean key" do
    value = -10
    (store[true] = value).should equal(value)

    value = 42
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = -10
    store[false] = 42
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, -10).should == -10
    store.fetch(false, 42).should == 42
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, -10, :option6 => 6).should == -10
  end
end

#################### store_booleankey_integervalue ####################

shared_examples_for 'store_booleankey_integervalue' do
  it "writes Integer values to keys that are Booleans like a Hash" do
    store[true] = -10
    store[true].should == -10
    store.load(true).should == -10

    store[false] = 42
    store[false].should == 42
    store.load(false).should == 42
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = -10
    store.key?(true).should == true
    store[false] = 42
    store.key?(false).should == true
  end

  it "stores Integer values with Boolean keys with #store" do
    value = -10
    store.store(true, value).should equal(value)
    store[true].should == -10
    store.load(true).should == -10

    value = 42
    store.store(false, value).should equal(value)
    store[false].should == 42
    store.load(false).should == 42
  end

  it "stores Boolean after clear" do
    store[true] = -10
    store[false] = 42
    store.clear.should equal(store)
    store[true] = -10
    store[true].should == -10
    store[false].should be_nil
  end

  it "removes and returns a Integer element with a Boolean key from the backing store via delete if it exists" do
    store[true] = -10
    store.delete(true).should == -10
    store.key?(true).should == false

    store[false] = 42
    store.delete(false).should == 42
    store.key?(false).should == false
  end

  it "overwrites existing Integer values with Boolean" do
    store[true] = -10
    store[true].should == -10
    store[true] = 42
    store[true].should == 42
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = -10
    store.fetch(true, 42).should == -10
  end
  it "does not run the block if the Boolean key is available" do
    store[true] = -10
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[false] = 42
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_booleankey_integervalue ####################

shared_examples_for 'persist_booleankey_integervalue' do
  it "persists Integer values with Boolean keys" do
    store[true] = -10
    store[false] = 42
    store.close

    store = new_store
    store[true].should == -10
    store[false].should == 42
  end
end

#################### null_booleankey_booleanvalue ####################

shared_examples_for 'null_booleankey_booleanvalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a Boolean key" do
    value = true
    (store[true] = value).should equal(value)

    value = false
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = true
    store[false] = false
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, true).should == true
    store.fetch(false, false).should == false
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, true, :option6 => 6).should == true
  end
end

#################### store_booleankey_booleanvalue ####################

shared_examples_for 'store_booleankey_booleanvalue' do
  it "writes Boolean values to keys that are Booleans like a Hash" do
    store[true] = true
    store[true].should == true
    store.load(true).should == true

    store[false] = false
    store[false].should == false
    store.load(false).should == false
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = true
    store.key?(true).should == true
    store[false] = false
    store.key?(false).should == true
  end

  it "stores Boolean values with Boolean keys with #store" do
    value = true
    store.store(true, value).should equal(value)
    store[true].should == true
    store.load(true).should == true

    value = false
    store.store(false, value).should equal(value)
    store[false].should == false
    store.load(false).should == false
  end

  it "stores Boolean after clear" do
    store[true] = true
    store[false] = false
    store.clear.should equal(store)
    store[true] = true
    store[true].should == true
    store[false].should be_nil
  end

  it "removes and returns a Boolean element with a Boolean key from the backing store via delete if it exists" do
    store[true] = true
    store.delete(true).should == true
    store.key?(true).should == false

    store[false] = false
    store.delete(false).should == false
    store.key?(false).should == false
  end

  it "overwrites existing Boolean values with Boolean" do
    store[true] = true
    store[true].should == true
    store[true] = false
    store[true].should == false
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = true
    store.fetch(true, false).should == true
  end
  it "does not run the block if the Boolean key is available" do
    store[true] = true
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[false] = false
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_booleankey_booleanvalue ####################

shared_examples_for 'persist_booleankey_booleanvalue' do
  it "persists Boolean values with Boolean keys" do
    store[true] = true
    store[false] = false
    store.close

    store = new_store
    store[true].should == true
    store[false].should == false
  end
end

#################### null_booleankey_stringvalue ####################

shared_examples_for 'null_booleankey_stringvalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same String value is returned when setting a Boolean key" do
    value = "strval1"
    (store[true] = value).should equal(value)

    value = "strval2"
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = "strval1"
    store[false] = "strval2"
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, "strval1").should == "strval1"
    store.fetch(false, "strval2").should == "strval2"
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_booleankey_stringvalue ####################

shared_examples_for 'store_booleankey_stringvalue' do
  it "writes String values to keys that are Booleans like a Hash" do
    store[true] = "strval1"
    store[true].should == "strval1"
    store.load(true).should == "strval1"

    store[false] = "strval2"
    store[false].should == "strval2"
    store.load(false).should == "strval2"
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = "strval1"
    store.key?(true).should == true
    store[false] = "strval2"
    store.key?(false).should == true
  end

  it "stores String values with Boolean keys with #store" do
    value = "strval1"
    store.store(true, value).should equal(value)
    store[true].should == "strval1"
    store.load(true).should == "strval1"

    value = "strval2"
    store.store(false, value).should equal(value)
    store[false].should == "strval2"
    store.load(false).should == "strval2"
  end

  it "stores Boolean after clear" do
    store[true] = "strval1"
    store[false] = "strval2"
    store.clear.should equal(store)
    store[true] = "strval1"
    store[true].should == "strval1"
    store[false].should be_nil
  end

  it "removes and returns a String element with a Boolean key from the backing store via delete if it exists" do
    store[true] = "strval1"
    store.delete(true).should == "strval1"
    store.key?(true).should == false

    store[false] = "strval2"
    store.delete(false).should == "strval2"
    store.key?(false).should == false
  end

  it "overwrites existing String values with Boolean" do
    store[true] = "strval1"
    store[true].should == "strval1"
    store[true] = "strval2"
    store[true].should == "strval2"
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = "strval1"
    store.fetch(true, "strval2").should == "strval1"
  end
  it "does not run the block if the Boolean key is available" do
    store[true] = "strval1"
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[false] = "strval2"
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_stringvalue ####################

shared_examples_for 'returndifferent_booleankey_stringvalue' do
  it "guarantees that a different String value is retrieved from the Boolean key" do
    value = "strval1"
    store[true] = "strval1"
    store[true].should_not be_equal("strval1")

    value = "strval2"
    store[false] = "strval2"
    store[false].should_not be_equal("strval2")
  end
end

#################### persist_booleankey_stringvalue ####################

shared_examples_for 'persist_booleankey_stringvalue' do
  it "persists String values with Boolean keys" do
    store[true] = "strval1"
    store[false] = "strval2"
    store.close

    store = new_store
    store[true].should == "strval1"
    store[false].should == "strval2"
  end
end

#################### null_booleankey_hashvalue ####################

shared_examples_for 'null_booleankey_hashvalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same Hash value is returned when setting a Boolean key" do
    value = {"hashval1"=>["array1", 1]}
    (store[true] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch(false, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_booleankey_hashvalue ####################

shared_examples_for 'store_booleankey_hashvalue' do
  it "writes Hash values to keys that are Booleans like a Hash" do
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store.load(true).should == {"hashval1"=>["array1", 1]}

    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = {"hashval1"=>["array1", 1]}
    store.key?(true).should == true
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(false).should == true
  end

  it "stores Hash values with Boolean keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store(true, value).should equal(value)
    store[true].should == {"hashval1"=>["array1", 1]}
    store.load(true).should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(false, value).should equal(value)
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores Boolean after clear" do
    store[true] = {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store[false].should be_nil
  end

  it "removes and returns a Hash element with a Boolean key from the backing store via delete if it exists" do
    store[true] = {"hashval1"=>["array1", 1]}
    store.delete(true).should == {"hashval1"=>["array1", 1]}
    store.key?(true).should == false

    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(false).should == false
  end

  it "overwrites existing Hash values with Boolean" do
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = {"hashval1"=>["array1", 1]}
    store.fetch(true, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the Boolean key is available" do
    store[true] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_hashvalue ####################

shared_examples_for 'returndifferent_booleankey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the Boolean key" do
    value = {"hashval1"=>["array1", 1]}
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_booleankey_hashvalue ####################

shared_examples_for 'persist_booleankey_hashvalue' do
  it "persists Hash values with Boolean keys" do
    store[true] = {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store[true].should == {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_booleankey_objectvalue ####################

shared_examples_for 'null_booleankey_objectvalue' do
  it "reads from keys that are Booleans like a Hash" do
    store[true].should == nil
    store.load(true).should == nil

    store[false].should == nil
    store.load(false).should == nil
  end

  it "guarantees that the same Object value is returned when setting a Boolean key" do
    value = Value.new(:objval1)
    (store[true] = value).should equal(value)

    value = Value.new(:objval2)
    (store[false] = value).should equal(value)
  end

  it "returns false from key? if a Boolean key is not available" do
    store.key?(true).should == false
    store.key?(false).should == false
  end

  it "returns nil from delete if an element for a Boolean key does not exist" do
    store.delete(true).should == nil
    store.delete(false).should == nil
  end

  it "removes all Boolean keys from the store with clear" do
    store[true] = Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(true).should_not ==  true
    store.key?(false).should_not == true
  end

  it "fetches a Boolean key with a default value with fetch, if the key is not available" do
    store.fetch(true, Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch(false, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a Boolean key with a block with fetch, if the key is not available" do
    key = true
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = false
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(true, :option1 => 1).should == false
    store.load(true, :option2 => 2).should == nil
    store.fetch(true, 42, :option3 => 3).should == 42
    store.fetch(true, :option3 => 3) { 42 }.should == 42
    store.delete(true, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(true, Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_booleankey_objectvalue ####################

shared_examples_for 'store_booleankey_objectvalue' do
  it "writes Object values to keys that are Booleans like a Hash" do
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store.load(true).should == Value.new(:objval1)

    store[false] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
    store.load(false).should == Value.new(:objval2)
  end

  it "returns true from key? if a Boolean key is available" do
    store[true] = Value.new(:objval1)
    store.key?(true).should == true
    store[false] = Value.new(:objval2)
    store.key?(false).should == true
  end

  it "stores Object values with Boolean keys with #store" do
    value = Value.new(:objval1)
    store.store(true, value).should equal(value)
    store[true].should == Value.new(:objval1)
    store.load(true).should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store(false, value).should equal(value)
    store[false].should == Value.new(:objval2)
    store.load(false).should == Value.new(:objval2)
  end

  it "stores Boolean after clear" do
    store[true] = Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store.clear.should equal(store)
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store[false].should be_nil
  end

  it "removes and returns a Object element with a Boolean key from the backing store via delete if it exists" do
    store[true] = Value.new(:objval1)
    store.delete(true).should == Value.new(:objval1)
    store.key?(true).should == false

    store[false] = Value.new(:objval2)
    store.delete(false).should == Value.new(:objval2)
    store.key?(false).should == false
  end

  it "overwrites existing Object values with Boolean" do
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store[true] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
  end

  it "fetches a Boolean key with a default value with fetch, if the key is available" do
    store[true] = Value.new(:objval1)
    store.fetch(true, Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the Boolean key is available" do
    store[true] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[false] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_objectvalue ####################

shared_examples_for 'returndifferent_booleankey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the Boolean key" do
    value = Value.new(:objval1)
    store[true] = Value.new(:objval1)
    store[true].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store[false] = Value.new(:objval2)
    store[false].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_booleankey_objectvalue ####################

shared_examples_for 'persist_booleankey_objectvalue' do
  it "persists Object values with Boolean keys" do
    store[true] = Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store.close

    store = new_store
    store[true].should == Value.new(:objval1)
    store[false].should == Value.new(:objval2)
  end
end

#################### null_stringkey_nilvalue ####################

shared_examples_for 'null_stringkey_nilvalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same Nil value is returned when setting a String key" do
    value = 0
    (store["strkey1"] = value).should equal(value)

    value = nil
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = 0
    store["strkey2"] = nil
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", 0).should == 0
    store.fetch("strkey2", nil).should == nil
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", 0, :option6 => 6).should == 0
  end
end

#################### store_stringkey_nilvalue ####################

shared_examples_for 'store_stringkey_nilvalue' do
  it "writes Nil values to keys that are Strings like a Hash" do
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store.load("strkey1").should == 0

    store["strkey2"] = nil
    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = 0
    store.key?("strkey1").should == true
    store["strkey2"] = nil
    store.key?("strkey2").should == true
  end

  it "stores Nil values with String keys with #store" do
    value = 0
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 0
    store.load("strkey1").should == 0

    value = nil
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "stores String after clear" do
    store["strkey1"] = 0
    store["strkey2"] = nil
    store.clear.should equal(store)
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store["strkey2"].should be_nil
  end

  it "removes and returns a Nil element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = 0
    store.delete("strkey1").should == 0
    store.key?("strkey1").should == false

    store["strkey2"] = nil
    store.delete("strkey2").should == nil
    store.key?("strkey2").should == false
  end

  it "overwrites existing Nil values with String" do
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store["strkey1"] = nil
    store["strkey1"].should == nil
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = 0
    store.fetch("strkey1", nil).should == 0
  end
end

#################### persist_stringkey_nilvalue ####################

shared_examples_for 'persist_stringkey_nilvalue' do
  it "persists Nil values with String keys" do
    store["strkey1"] = 0
    store["strkey2"] = nil
    store.close

    store = new_store
    store["strkey1"].should == 0
    store["strkey2"].should == nil
  end
end

#################### null_stringkey_integervalue ####################

shared_examples_for 'null_stringkey_integervalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same Integer value is returned when setting a String key" do
    value = -10
    (store["strkey1"] = value).should equal(value)

    value = 42
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = -10
    store["strkey2"] = 42
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", -10).should == -10
    store.fetch("strkey2", 42).should == 42
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", -10, :option6 => 6).should == -10
  end
end

#################### store_stringkey_integervalue ####################

shared_examples_for 'store_stringkey_integervalue' do
  it "writes Integer values to keys that are Strings like a Hash" do
    store["strkey1"] = -10
    store["strkey1"].should == -10
    store.load("strkey1").should == -10

    store["strkey2"] = 42
    store["strkey2"].should == 42
    store.load("strkey2").should == 42
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = -10
    store.key?("strkey1").should == true
    store["strkey2"] = 42
    store.key?("strkey2").should == true
  end

  it "stores Integer values with String keys with #store" do
    value = -10
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == -10
    store.load("strkey1").should == -10

    value = 42
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 42
    store.load("strkey2").should == 42
  end

  it "stores String after clear" do
    store["strkey1"] = -10
    store["strkey2"] = 42
    store.clear.should equal(store)
    store["strkey1"] = -10
    store["strkey1"].should == -10
    store["strkey2"].should be_nil
  end

  it "removes and returns a Integer element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = -10
    store.delete("strkey1").should == -10
    store.key?("strkey1").should == false

    store["strkey2"] = 42
    store.delete("strkey2").should == 42
    store.key?("strkey2").should == false
  end

  it "overwrites existing Integer values with String" do
    store["strkey1"] = -10
    store["strkey1"].should == -10
    store["strkey1"] = 42
    store["strkey1"].should == 42
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = -10
    store.fetch("strkey1", 42).should == -10
  end
  it "does not run the block if the String key is available" do
    store["strkey1"] = -10
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store["strkey2"] = 42
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_stringkey_integervalue ####################

shared_examples_for 'persist_stringkey_integervalue' do
  it "persists Integer values with String keys" do
    store["strkey1"] = -10
    store["strkey2"] = 42
    store.close

    store = new_store
    store["strkey1"].should == -10
    store["strkey2"].should == 42
  end
end

#################### null_stringkey_booleanvalue ####################

shared_examples_for 'null_stringkey_booleanvalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a String key" do
    value = true
    (store["strkey1"] = value).should equal(value)

    value = false
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = true
    store["strkey2"] = false
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", true).should == true
    store.fetch("strkey2", false).should == false
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", true, :option6 => 6).should == true
  end
end

#################### store_stringkey_booleanvalue ####################

shared_examples_for 'store_stringkey_booleanvalue' do
  it "writes Boolean values to keys that are Strings like a Hash" do
    store["strkey1"] = true
    store["strkey1"].should == true
    store.load("strkey1").should == true

    store["strkey2"] = false
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = true
    store.key?("strkey1").should == true
    store["strkey2"] = false
    store.key?("strkey2").should == true
  end

  it "stores Boolean values with String keys with #store" do
    value = true
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == true
    store.load("strkey1").should == true

    value = false
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it "stores String after clear" do
    store["strkey1"] = true
    store["strkey2"] = false
    store.clear.should equal(store)
    store["strkey1"] = true
    store["strkey1"].should == true
    store["strkey2"].should be_nil
  end

  it "removes and returns a Boolean element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = true
    store.delete("strkey1").should == true
    store.key?("strkey1").should == false

    store["strkey2"] = false
    store.delete("strkey2").should == false
    store.key?("strkey2").should == false
  end

  it "overwrites existing Boolean values with String" do
    store["strkey1"] = true
    store["strkey1"].should == true
    store["strkey1"] = false
    store["strkey1"].should == false
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = true
    store.fetch("strkey1", false).should == true
  end
  it "does not run the block if the String key is available" do
    store["strkey1"] = true
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store["strkey2"] = false
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_stringkey_booleanvalue ####################

shared_examples_for 'persist_stringkey_booleanvalue' do
  it "persists Boolean values with String keys" do
    store["strkey1"] = true
    store["strkey2"] = false
    store.close

    store = new_store
    store["strkey1"].should == true
    store["strkey2"].should == false
  end
end

#################### null_stringkey_stringvalue ####################

shared_examples_for 'null_stringkey_stringvalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same String value is returned when setting a String key" do
    value = "strval1"
    (store["strkey1"] = value).should equal(value)

    value = "strval2"
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = "strval1"
    store["strkey2"] = "strval2"
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", "strval1").should == "strval1"
    store.fetch("strkey2", "strval2").should == "strval2"
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_stringkey_stringvalue ####################

shared_examples_for 'store_stringkey_stringvalue' do
  it "writes String values to keys that are Strings like a Hash" do
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store.load("strkey1").should == "strval1"

    store["strkey2"] = "strval2"
    store["strkey2"].should == "strval2"
    store.load("strkey2").should == "strval2"
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = "strval1"
    store.key?("strkey1").should == true
    store["strkey2"] = "strval2"
    store.key?("strkey2").should == true
  end

  it "stores String values with String keys with #store" do
    value = "strval1"
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == "strval1"
    store.load("strkey1").should == "strval1"

    value = "strval2"
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == "strval2"
    store.load("strkey2").should == "strval2"
  end

  it "stores String after clear" do
    store["strkey1"] = "strval1"
    store["strkey2"] = "strval2"
    store.clear.should equal(store)
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store["strkey2"].should be_nil
  end

  it "removes and returns a String element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = "strval1"
    store.delete("strkey1").should == "strval1"
    store.key?("strkey1").should == false

    store["strkey2"] = "strval2"
    store.delete("strkey2").should == "strval2"
    store.key?("strkey2").should == false
  end

  it "overwrites existing String values with String" do
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store["strkey1"] = "strval2"
    store["strkey1"].should == "strval2"
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = "strval1"
    store.fetch("strkey1", "strval2").should == "strval1"
  end
  it "does not run the block if the String key is available" do
    store["strkey1"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store["strkey2"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_stringvalue ####################

shared_examples_for 'returndifferent_stringkey_stringvalue' do
  it "guarantees that a different String value is retrieved from the String key" do
    value = "strval1"
    store["strkey1"] = "strval1"
    store["strkey1"].should_not be_equal("strval1")

    value = "strval2"
    store["strkey2"] = "strval2"
    store["strkey2"].should_not be_equal("strval2")
  end
end

#################### persist_stringkey_stringvalue ####################

shared_examples_for 'persist_stringkey_stringvalue' do
  it "persists String values with String keys" do
    store["strkey1"] = "strval1"
    store["strkey2"] = "strval2"
    store.close

    store = new_store
    store["strkey1"].should == "strval1"
    store["strkey2"].should == "strval2"
  end
end

#################### null_stringkey_hashvalue ####################

shared_examples_for 'null_stringkey_hashvalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same Hash value is returned when setting a String key" do
    value = {"hashval1"=>["array1", 1]}
    (store["strkey1"] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch("strkey2", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_stringkey_hashvalue ####################

shared_examples_for 'store_stringkey_hashvalue' do
  it "writes Hash values to keys that are Strings like a Hash" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey1").should == {"hashval1"=>["array1", 1]}

    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.key?("strkey1").should == true
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey2").should == true
  end

  it "stores Hash values with String keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey1").should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores String after clear" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store["strkey2"].should be_nil
  end

  it "removes and returns a Hash element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.delete("strkey1").should == {"hashval1"=>["array1", 1]}
    store.key?("strkey1").should == false

    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey2").should == false
  end

  it "overwrites existing Hash values with String" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.fetch("strkey1", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the String key is available" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_hashvalue ####################

shared_examples_for 'returndifferent_stringkey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the String key" do
    value = {"hashval1"=>["array1", 1]}
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_stringkey_hashvalue ####################

shared_examples_for 'persist_stringkey_hashvalue' do
  it "persists Hash values with String keys" do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_stringkey_objectvalue ####################

shared_examples_for 'null_stringkey_objectvalue' do
  it "reads from keys that are Strings like a Hash" do
    store["strkey1"].should == nil
    store.load("strkey1").should == nil

    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it "guarantees that the same Object value is returned when setting a String key" do
    value = Value.new(:objval1)
    (store["strkey1"] = value).should equal(value)

    value = Value.new(:objval2)
    (store["strkey2"] = value).should equal(value)
  end

  it "returns false from key? if a String key is not available" do
    store.key?("strkey1").should == false
    store.key?("strkey2").should == false
  end

  it "returns nil from delete if an element for a String key does not exist" do
    store.delete("strkey1").should == nil
    store.delete("strkey2").should == nil
  end

  it "removes all String keys from the store with clear" do
    store["strkey1"] = Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("strkey1").should_not ==  true
    store.key?("strkey2").should_not == true
  end

  it "fetches a String key with a default value with fetch, if the key is not available" do
    store.fetch("strkey1", Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch("strkey2", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a String key with a block with fetch, if the key is not available" do
    key = "strkey1"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = "strkey2"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?("strkey1", :option1 => 1).should == false
    store.load("strkey1", :option2 => 2).should == nil
    store.fetch("strkey1", 42, :option3 => 3).should == 42
    store.fetch("strkey1", :option3 => 3) { 42 }.should == 42
    store.delete("strkey1", :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store("strkey1", Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_stringkey_objectvalue ####################

shared_examples_for 'store_stringkey_objectvalue' do
  it "writes Object values to keys that are Strings like a Hash" do
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store.load("strkey1").should == Value.new(:objval1)

    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
    store.load("strkey2").should == Value.new(:objval2)
  end

  it "returns true from key? if a String key is available" do
    store["strkey1"] = Value.new(:objval1)
    store.key?("strkey1").should == true
    store["strkey2"] = Value.new(:objval2)
    store.key?("strkey2").should == true
  end

  it "stores Object values with String keys with #store" do
    value = Value.new(:objval1)
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == Value.new(:objval1)
    store.load("strkey1").should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == Value.new(:objval2)
    store.load("strkey2").should == Value.new(:objval2)
  end

  it "stores String after clear" do
    store["strkey1"] = Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store["strkey2"].should be_nil
  end

  it "removes and returns a Object element with a String key from the backing store via delete if it exists" do
    store["strkey1"] = Value.new(:objval1)
    store.delete("strkey1").should == Value.new(:objval1)
    store.key?("strkey1").should == false

    store["strkey2"] = Value.new(:objval2)
    store.delete("strkey2").should == Value.new(:objval2)
    store.key?("strkey2").should == false
  end

  it "overwrites existing Object values with String" do
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store["strkey1"] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
  end

  it "fetches a String key with a default value with fetch, if the key is available" do
    store["strkey1"] = Value.new(:objval1)
    store.fetch("strkey1", Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the String key is available" do
    store["strkey1"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store["strkey2"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_objectvalue ####################

shared_examples_for 'returndifferent_stringkey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the String key" do
    value = Value.new(:objval1)
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_stringkey_objectvalue ####################

shared_examples_for 'persist_stringkey_objectvalue' do
  it "persists Object values with String keys" do
    store["strkey1"] = Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store.close

    store = new_store
    store["strkey1"].should == Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval2)
  end
end

#################### null_objectkey_nilvalue ####################

shared_examples_for 'null_objectkey_nilvalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same Nil value is returned when setting a Object key" do
    value = 0
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = nil
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey2)] = nil
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), 0).should == 0
    store.fetch(Value.new(:objkey2), nil).should == nil
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), 0, :option6 => 6).should == 0
  end
end

#################### store_objectkey_nilvalue ####################

shared_examples_for 'store_objectkey_nilvalue' do
  it "writes Nil values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store.load(Value.new(:objkey1)).should == 0

    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = 0
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = nil
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores Nil values with Object keys with #store" do
    value = 0
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 0
    store.load(Value.new(:objkey1)).should == 0

    value = nil
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey2)] = nil
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a Nil element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = 0
    store.delete(Value.new(:objkey1)).should == 0
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = nil
    store.delete(Value.new(:objkey2)).should == nil
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing Nil values with Object" do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey1)].should == nil
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = 0
    store.fetch(Value.new(:objkey1), nil).should == 0
  end
end

#################### persist_objectkey_nilvalue ####################

shared_examples_for 'persist_objectkey_nilvalue' do
  it "persists Nil values with Object keys" do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey2)] = nil
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == 0
    store[Value.new(:objkey2)].should == nil
  end
end

#################### null_objectkey_integervalue ####################

shared_examples_for 'null_objectkey_integervalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same Integer value is returned when setting a Object key" do
    value = -10
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = 42
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey2)] = 42
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), -10).should == -10
    store.fetch(Value.new(:objkey2), 42).should == 42
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), -10, :option6 => 6).should == -10
  end
end

#################### store_objectkey_integervalue ####################

shared_examples_for 'store_objectkey_integervalue' do
  it "writes Integer values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey1)].should == -10
    store.load(Value.new(:objkey1)).should == -10

    store[Value.new(:objkey2)] = 42
    store[Value.new(:objkey2)].should == 42
    store.load(Value.new(:objkey2)).should == 42
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = -10
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = 42
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores Integer values with Object keys with #store" do
    value = -10
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == -10
    store.load(Value.new(:objkey1)).should == -10

    value = 42
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 42
    store.load(Value.new(:objkey2)).should == 42
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey2)] = 42
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey1)].should == -10
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a Integer element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = -10
    store.delete(Value.new(:objkey1)).should == -10
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = 42
    store.delete(Value.new(:objkey2)).should == 42
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing Integer values with Object" do
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey1)].should == -10
    store[Value.new(:objkey1)] = 42
    store[Value.new(:objkey1)].should == 42
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = -10
    store.fetch(Value.new(:objkey1), 42).should == -10
  end
  it "does not run the block if the Object key is available" do
    store[Value.new(:objkey1)] = -10
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[Value.new(:objkey2)] = 42
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_objectkey_integervalue ####################

shared_examples_for 'persist_objectkey_integervalue' do
  it "persists Integer values with Object keys" do
    store[Value.new(:objkey1)] = -10
    store[Value.new(:objkey2)] = 42
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == -10
    store[Value.new(:objkey2)].should == 42
  end
end

#################### null_objectkey_booleanvalue ####################

shared_examples_for 'null_objectkey_booleanvalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a Object key" do
    value = true
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = false
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), true).should == true
    store.fetch(Value.new(:objkey2), false).should == false
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), true, :option6 => 6).should == true
  end
end

#################### store_objectkey_booleanvalue ####################

shared_examples_for 'store_objectkey_booleanvalue' do
  it "writes Boolean values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store.load(Value.new(:objkey1)).should == true

    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = true
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = false
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores Boolean values with Object keys with #store" do
    value = true
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == true
    store.load(Value.new(:objkey1)).should == true

    value = false
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a Boolean element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = true
    store.delete(Value.new(:objkey1)).should == true
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = false
    store.delete(Value.new(:objkey2)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing Boolean values with Object" do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = true
    store.fetch(Value.new(:objkey1), false).should == true
  end
  it "does not run the block if the Object key is available" do
    store[Value.new(:objkey1)] = true
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[Value.new(:objkey2)] = false
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_objectkey_booleanvalue ####################

shared_examples_for 'persist_objectkey_booleanvalue' do
  it "persists Boolean values with Object keys" do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey2)] = false
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == true
    store[Value.new(:objkey2)].should == false
  end
end

#################### null_objectkey_stringvalue ####################

shared_examples_for 'null_objectkey_stringvalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same String value is returned when setting a Object key" do
    value = "strval1"
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = "strval2"
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), "strval1").should == "strval1"
    store.fetch(Value.new(:objkey2), "strval2").should == "strval2"
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_objectkey_stringvalue ####################

shared_examples_for 'store_objectkey_stringvalue' do
  it "writes String values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store.load(Value.new(:objkey1)).should == "strval1"

    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
    store.load(Value.new(:objkey2)).should == "strval2"
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = "strval1"
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = "strval2"
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores String values with Object keys with #store" do
    value = "strval1"
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == "strval1"
    store.load(Value.new(:objkey1)).should == "strval1"

    value = "strval2"
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == "strval2"
    store.load(Value.new(:objkey2)).should == "strval2"
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a String element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = "strval1"
    store.delete(Value.new(:objkey1)).should == "strval1"
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = "strval2"
    store.delete(Value.new(:objkey2)).should == "strval2"
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing String values with Object" do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = "strval1"
    store.fetch(Value.new(:objkey1), "strval2").should == "strval1"
  end
  it "does not run the block if the Object key is available" do
    store[Value.new(:objkey1)] = "strval1"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[Value.new(:objkey2)] = "strval2"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_stringvalue ####################

shared_examples_for 'returndifferent_objectkey_stringvalue' do
  it "guarantees that a different String value is retrieved from the Object key" do
    value = "strval1"
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should_not be_equal("strval1")

    value = "strval2"
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should_not be_equal("strval2")
  end
end

#################### persist_objectkey_stringvalue ####################

shared_examples_for 'persist_objectkey_stringvalue' do
  it "persists String values with Object keys" do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == "strval1"
    store[Value.new(:objkey2)].should == "strval2"
  end
end

#################### null_objectkey_hashvalue ####################

shared_examples_for 'null_objectkey_hashvalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same Hash value is returned when setting a Object key" do
    value = {"hashval1"=>["array1", 1]}
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch(Value.new(:objkey2), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_objectkey_hashvalue ####################

shared_examples_for 'store_objectkey_hashvalue' do
  it "writes Hash values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}

    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores Hash values with Object keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a Hash element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.delete(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing Hash values with Object" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.fetch(Value.new(:objkey1), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the Object key is available" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_hashvalue ####################

shared_examples_for 'returndifferent_objectkey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the Object key" do
    value = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_objectkey_hashvalue ####################

shared_examples_for 'persist_objectkey_hashvalue' do
  it "persists Hash values with Object keys" do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_objectkey_objectvalue ####################

shared_examples_for 'null_objectkey_objectvalue' do
  it "reads from keys that are Objects like a Hash" do
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil

    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it "guarantees that the same Object value is returned when setting a Object key" do
    value = Value.new(:objval1)
    (store[Value.new(:objkey1)] = value).should equal(value)

    value = Value.new(:objval2)
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it "returns false from key? if a Object key is not available" do
    store.key?(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey2)).should == false
  end

  it "returns nil from delete if an element for a Object key does not exist" do
    store.delete(Value.new(:objkey1)).should == nil
    store.delete(Value.new(:objkey2)).should == nil
  end

  it "removes all Object keys from the store with clear" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should_not ==  true
    store.key?(Value.new(:objkey2)).should_not == true
  end

  it "fetches a Object key with a default value with fetch, if the key is not available" do
    store.fetch(Value.new(:objkey1), Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch(Value.new(:objkey2), Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a Object key with a block with fetch, if the key is not available" do
    key = Value.new(:objkey1)
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = Value.new(:objkey2)
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?(Value.new(:objkey1), :option1 => 1).should == false
    store.load(Value.new(:objkey1), :option2 => 2).should == nil
    store.fetch(Value.new(:objkey1), 42, :option3 => 3).should == 42
    store.fetch(Value.new(:objkey1), :option3 => 3) { 42 }.should == 42
    store.delete(Value.new(:objkey1), :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store(Value.new(:objkey1), Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_objectkey_objectvalue ####################

shared_examples_for 'store_objectkey_objectvalue' do
  it "writes Object values to keys that are Objects like a Hash" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store.load(Value.new(:objkey1)).should == Value.new(:objval1)

    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store.load(Value.new(:objkey2)).should == Value.new(:objval2)
  end

  it "returns true from key? if a Object key is available" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.key?(Value.new(:objkey1)).should == true
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.key?(Value.new(:objkey2)).should == true
  end

  it "stores Object values with Object keys with #store" do
    value = Value.new(:objval1)
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store.load(Value.new(:objkey1)).should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store.load(Value.new(:objkey2)).should == Value.new(:objval2)
  end

  it "stores Object after clear" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store[Value.new(:objkey2)].should be_nil
  end

  it "removes and returns a Object element with a Object key from the backing store via delete if it exists" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.delete(Value.new(:objkey1)).should == Value.new(:objval1)
    store.key?(Value.new(:objkey1)).should == false

    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.delete(Value.new(:objkey2)).should == Value.new(:objval2)
    store.key?(Value.new(:objkey2)).should == false
  end

  it "overwrites existing Object values with Object" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
  end

  it "fetches a Object key with a default value with fetch, if the key is available" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.fetch(Value.new(:objkey1), Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the Object key is available" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[Value.new(:objkey2)] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_objectvalue ####################

shared_examples_for 'returndifferent_objectkey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the Object key" do
    value = Value.new(:objval1)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_objectkey_objectvalue ####################

shared_examples_for 'persist_objectkey_objectvalue' do
  it "persists Object values with Object keys" do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.close

    store = new_store
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
  end
end

#################### null_hashkey_nilvalue ####################

shared_examples_for 'null_hashkey_nilvalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same Nil value is returned when setting a Hash key" do
    value = 0
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = nil
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, 0).should == 0
    store.fetch({"hashkey3"=>"hashkey4"}, nil).should == nil
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 0, :option6 => 6).should == 0
  end
end

#################### store_hashkey_nilvalue ####################

shared_examples_for 'store_hashkey_nilvalue' do
  it "writes Nil values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store.load({"hashkey1"=>"hashkey2"}).should == 0

    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores Nil values with Hash keys with #store" do
    value = 0
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store.load({"hashkey1"=>"hashkey2"}).should == 0

    value = nil
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a Nil element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.delete({"hashkey1"=>"hashkey2"}).should == 0
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing Nil values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.fetch({"hashkey1"=>"hashkey2"}, nil).should == 0
  end
end

#################### persist_hashkey_nilvalue ####################

shared_examples_for 'persist_hashkey_nilvalue' do
  it "persists Nil values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store[{"hashkey3"=>"hashkey4"}].should == nil
  end
end

#################### null_hashkey_integervalue ####################

shared_examples_for 'null_hashkey_integervalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same Integer value is returned when setting a Hash key" do
    value = -10
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = 42
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey3"=>"hashkey4"}] = 42
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, -10).should == -10
    store.fetch({"hashkey3"=>"hashkey4"}, 42).should == 42
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = -10
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = 42
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, -10, :option6 => 6).should == -10
  end
end

#################### store_hashkey_integervalue ####################

shared_examples_for 'store_hashkey_integervalue' do
  it "writes Integer values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey1"=>"hashkey2"}].should == -10
    store.load({"hashkey1"=>"hashkey2"}).should == -10

    store[{"hashkey3"=>"hashkey4"}] = 42
    store[{"hashkey3"=>"hashkey4"}].should == 42
    store.load({"hashkey3"=>"hashkey4"}).should == 42
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = 42
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores Integer values with Hash keys with #store" do
    value = -10
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == -10
    store.load({"hashkey1"=>"hashkey2"}).should == -10

    value = 42
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 42
    store.load({"hashkey3"=>"hashkey4"}).should == 42
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey3"=>"hashkey4"}] = 42
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey1"=>"hashkey2"}].should == -10
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a Integer element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store.delete({"hashkey1"=>"hashkey2"}).should == -10
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = 42
    store.delete({"hashkey3"=>"hashkey4"}).should == 42
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing Integer values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey1"=>"hashkey2"}].should == -10
    store[{"hashkey1"=>"hashkey2"}] = 42
    store[{"hashkey1"=>"hashkey2"}].should == 42
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store.fetch({"hashkey1"=>"hashkey2"}, 42).should == -10
  end
  it "does not run the block if the Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[{"hashkey3"=>"hashkey4"}] = 42
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_hashkey_integervalue ####################

shared_examples_for 'persist_hashkey_integervalue' do
  it "persists Integer values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = -10
    store[{"hashkey3"=>"hashkey4"}] = 42
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == -10
    store[{"hashkey3"=>"hashkey4"}].should == 42
  end
end

#################### null_hashkey_booleanvalue ####################

shared_examples_for 'null_hashkey_booleanvalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same Boolean value is returned when setting a Hash key" do
    value = true
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = false
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, true).should == true
    store.fetch({"hashkey3"=>"hashkey4"}, false).should == false
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, true, :option6 => 6).should == true
  end
end

#################### store_hashkey_booleanvalue ####################

shared_examples_for 'store_hashkey_booleanvalue' do
  it "writes Boolean values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store.load({"hashkey1"=>"hashkey2"}).should == true

    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores Boolean values with Hash keys with #store" do
    value = true
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == true
    store.load({"hashkey1"=>"hashkey2"}).should == true

    value = false
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a Boolean element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.delete({"hashkey1"=>"hashkey2"}).should == true
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = false
    store.delete({"hashkey3"=>"hashkey4"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing Boolean values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.fetch({"hashkey1"=>"hashkey2"}, false).should == true
  end
  it "does not run the block if the Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = true
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[{"hashkey3"=>"hashkey4"}] = false
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_hashkey_booleanvalue ####################

shared_examples_for 'persist_hashkey_booleanvalue' do
  it "persists Boolean values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == true
    store[{"hashkey3"=>"hashkey4"}].should == false
  end
end

#################### null_hashkey_stringvalue ####################

shared_examples_for 'null_hashkey_stringvalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same String value is returned when setting a Hash key" do
    value = "strval1"
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = "strval2"
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, "strval1").should == "strval1"
    store.fetch({"hashkey3"=>"hashkey4"}, "strval2").should == "strval2"
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, "strval1", :option6 => 6).should == "strval1"
  end
end

#################### store_hashkey_stringvalue ####################

shared_examples_for 'store_hashkey_stringvalue' do
  it "writes String values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval1"

    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval2"
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores String values with Hash keys with #store" do
    value = "strval1"
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval1"

    value = "strval2"
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval2"
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a String element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.delete({"hashkey1"=>"hashkey2"}).should == "strval1"
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.delete({"hashkey3"=>"hashkey4"}).should == "strval2"
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing String values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.fetch({"hashkey1"=>"hashkey2"}, "strval2").should == "strval1"
  end
  it "does not run the block if the Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_stringvalue ####################

shared_examples_for 'returndifferent_hashkey_stringvalue' do
  it "guarantees that a different String value is retrieved from the Hash key" do
    value = "strval1"
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal("strval1")

    value = "strval2"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal("strval2")
  end
end

#################### persist_hashkey_stringvalue ####################

shared_examples_for 'persist_hashkey_stringvalue' do
  it "persists String values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
  end
end

#################### null_hashkey_hashvalue ####################

shared_examples_for 'null_hashkey_hashvalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same Hash value is returned when setting a Hash key" do
    value = {"hashval1"=>["array1", 1]}
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
    store.fetch({"hashkey3"=>"hashkey4"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, {"hashval1"=>["array1", 1]}, :option6 => 6).should == {"hashval1"=>["array1", 1]}
  end
end

#################### store_hashkey_hashvalue ####################

shared_examples_for 'store_hashkey_hashvalue' do
  it "writes Hash values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}

    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores Hash values with Hash keys with #store" do
    value = {"hashval1"=>["array1", 1]}
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a Hash element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.delete({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing Hash values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end
  it "does not run the block if the Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_hashvalue ####################

shared_examples_for 'returndifferent_hashkey_hashvalue' do
  it "guarantees that a different Hash value is retrieved from the Hash key" do
    value = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal({"hashval1"=>["array1", 1]})

    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal({"hashval3"=>["array2", {"hashval4"=>42}]})
  end
end

#################### persist_hashkey_hashvalue ####################

shared_examples_for 'persist_hashkey_hashvalue' do
  it "persists Hash values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_hashkey_objectvalue ####################

shared_examples_for 'null_hashkey_objectvalue' do
  it "reads from keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil

    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "guarantees that the same Object value is returned when setting a Hash key" do
    value = Value.new(:objval1)
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)

    value = Value.new(:objval2)
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it "returns false from key? if a Hash key is not available" do
    store.key?({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "returns nil from delete if an element for a Hash key does not exist" do
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
  end

  it "removes all Hash keys from the store with clear" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should_not ==  true
    store.key?({"hashkey3"=>"hashkey4"}).should_not == true
  end

  it "fetches a Hash key with a default value with fetch, if the key is not available" do
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval1)).should == Value.new(:objval1)
    store.fetch({"hashkey3"=>"hashkey4"}, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it "fetches a Hash key with a block with fetch, if the key is not available" do
    key = {"hashkey1"=>"hashkey2"}
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)

    key = {"hashkey3"=>"hashkey4"}
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'should accept options' do
    store.key?({"hashkey1"=>"hashkey2"}, :option1 => 1).should == false
    store.load({"hashkey1"=>"hashkey2"}, :option2 => 2).should == nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, :option3 => 3).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, :option3 => 3) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, :option4 => 4).should == nil
    store.clear(:option5 => 5).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, Value.new(:objval1), :option6 => 6).should == Value.new(:objval1)
  end
end

#################### store_hashkey_objectvalue ####################

shared_examples_for 'store_hashkey_objectvalue' do
  it "writes Object values to keys that are Hashs like a Hash" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)

    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
  end

  it "returns true from key? if a Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.key?({"hashkey1"=>"hashkey2"}).should == true
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.key?({"hashkey3"=>"hashkey4"}).should == true
  end

  it "stores Object values with Hash keys with #store" do
    value = Value.new(:objval1)
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)

    value = Value.new(:objval2)
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
  end

  it "stores Hash after clear" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it "removes and returns a Object element with a Hash key from the backing store via delete if it exists" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.delete({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)
    store.key?({"hashkey1"=>"hashkey2"}).should == false

    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.delete({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
    store.key?({"hashkey3"=>"hashkey4"}).should == false
  end

  it "overwrites existing Object values with Hash" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
  end

  it "fetches a Hash key with a default value with fetch, if the key is available" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval2)).should == Value.new(:objval1)
  end
  it "does not run the block if the Hash key is available" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'

    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_objectvalue ####################

shared_examples_for 'returndifferent_hashkey_objectvalue' do
  it "guarantees that a different Object value is retrieved from the Hash key" do
    value = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(Value.new(:objval1))

    value = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(Value.new(:objval2))
  end
end

#################### persist_hashkey_objectvalue ####################

shared_examples_for 'persist_hashkey_objectvalue' do
  it "persists Object values with Hash keys" do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.close

    store = new_store
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
  end
end

#################### not_persist ####################

shared_examples_for 'not_persist' do
  it "does not persist values" do
    store['key'] = 'val'
    store.close

    store = new_store
    store['key'].should be_nil
  end
end

#################### expires ####################

shared_examples_for 'expires' do
  it 'should support expires on store and #[]' do
    store.store('key1', 'val1', :expires => 2)
    store['key1'].should == 'val1'
    sleep 1
    store['key1'].should == 'val1'
    sleep 2
    store['key1'].should == nil
  end

  it 'should support expires on store and load' do
    store.store('key1', 'val1', :expires => 2)
    store.load('key1').should == 'val1'
    sleep 1
    store.load('key1').should == 'val1'
    sleep 2
    store.load('key1').should == nil
  end

  it 'should support expires on store and key?' do
    store.store('key1', 'val1', :expires => 2)
    store.key?('key1').should == true
    sleep 1
    store.key?('key1').should == true
    sleep 2
    store.key?('key1').should == false
  end

  it 'should support updating the expiration time in load' do
    store.store('key2', 'val2', :expires => 2)
    store['key2'].should == 'val2'
    sleep 1
    store.load('key2', :expires => 3).should == 'val2'
    store['key2'].should == 'val2'
    sleep 1
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should == nil
  end

  it 'should support updating the expiration time in key?' do
    store.store('key2', 'val2', :expires => 2)
    store['key2'].should == 'val2'
    sleep 1
    store.key?('key2', :expires => 3).should be_true
    store['key2'].should == 'val2'
    sleep 1
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should == nil
  end

  it 'should support updating the expiration time in fetch' do
    store.store('key1', 'val1', :expires => 2)
    store['key1'].should == 'val1'
    sleep 1
    store.fetch('key1', nil, :expires => 3).should == 'val1'
    store['key1'].should == 'val1'
    sleep 1
    store['key1'].should == 'val1'
    sleep 3
    store['key1'].should == nil
  end

  it 'should respect expires in delete' do
    store.store('key2', 'val2', :expires => 2)
    store['key2'].should == 'val2'
    sleep 1
    store['key2'].should == 'val2'
    sleep 2
    store.delete('key2').should == nil
  end

  it 'should support the #expires syntactic sugar' do
    store['longlive_key'] = 'longlive_value'
    store.expires(2).store('key2', 'val2')
    store['key2'].should == 'val2'
    sleep 1
    store['key2'].should == 'val2'
    sleep 2
    store.delete('key2').should == nil
    store['longlive_key'].should == 'longlive_value'
  end
end

#################### not_increment ####################

shared_examples_for 'not_increment' do
  it 'should not support #increment' do
    expect do
      store.increment('inckey')
    end.to raise_error(NotImplementedError)
  end

  it 'should not support #decrement' do
    expect do
      store.increment('inckey')
    end.to raise_error(NotImplementedError)
  end
end

#################### increment ####################

shared_examples_for 'increment' do
  it 'should initialize in #increment with 1' do
    store.key?('inckey').should be_false
    store.increment('inckey').should == 1
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '1'
    store.raw.load('inckey').should == '1'
    store.load('inckey', :raw => true).should == '1'

    # WARNING: Undefined behaviour!
    result = safe_load_value(store.raw['inckey'])
    store['inckey'].should == result

    store.delete('inckey', :raw => true).should == '1'
    store.key?('inckey').should be_false
  end

  it 'should initialize in #increment with higher value' do
    store.increment('inckey', 42).should == 42
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '42'

    # WARNING: Undefined behaviour!
    result = safe_load_value(store.raw['inckey'])
    store['inckey'].should == result

    store.delete('inckey', :raw => true).should == '42'
  end

  it 'should initialize in #increment with 0' do
    store.increment('inckey', 0).should == 0
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '0'

    # WARNING: Undefined behaviour!
    result = safe_load_value(store.raw['inckey'])
    store['inckey'].should == result

    store.delete('inckey', :raw => true).should == '0'
  end

  it 'should support deleting integer value' do
    store.increment('inckey').should == 1

    # WARNING: Undefined behaviour!
    result = safe_load_value(store.raw['inckey'])
    store.delete('inckey').should == result

    store.key?('inckey').should be_false
  end

  it 'should initialize in #decrement with 0' do
    store.decrement('inckey', 0).should == 0
    store.raw['inckey'].should == '0'
  end

  it 'should initialize in #decrement with negative value' do
    store.decrement('inckey', -42).should == 42
    store.raw['inckey'].should == '42'
  end

  it 'should support incrementing existing value by value' do
    store.increment('inckey').should == 1
    store.increment('inckey', 42).should == 43
    store.raw['inckey'].should == '43'
  end

  it 'should support decrementing existing value by value' do
    store.increment('inckey').should == 1
    store.decrement('inckey').should == 0
    store.increment('inckey', 42).should == 42
    store.decrement('inckey', 2).should == 40
    store.raw['inckey'].should == '40'
  end

  it 'should support incrementing existing value by 0' do
    store.increment('inckey').should == 1
    store.increment('inckey', 0).should == 1
    store.raw['inckey'].should == '1'
  end

  it 'should support decrementing existing value' do
    store.increment('inckey', 10).should == 10
    store.increment('inckey', -5).should == 5
    store.raw['inckey'].should == '5'
    store.increment('inckey', -5).should == 0
    store.raw['inckey'].should == '0'
  end

  it 'interpret raw value as integer' do
    store.store('inckey', '42', :raw => true)
    store.increment('inckey').should == 43
    store.raw['inckey'].should == '43'
  end

  it 'should raise error in #increment on non integer value' do
    store['strkey'] = 'value'
    expect do
      store.increment('strkey')
    end.to raise_error
  end

  it 'should raise error in #decrement on non integer value' do
    store['strkey'] = 'value'
    expect do
      store.decrement('strkey')
    end.to raise_error
  end
end

#################### marshallable_key ####################

shared_examples_for 'marshallable_key' do
  it 'refuses to #[] from keys that cannot be marshalled' do
    expect do
      store[Struct.new(:foo).new(:bar)]
    end.to raise_error(marshal_error)
  end

  it 'refuses to load from keys that cannot be marshalled' do
    expect do
      store.load(Struct.new(:foo).new(:bar))
    end.to raise_error(marshal_error)
  end

  it 'refuses to fetch from keys that cannot be marshalled' do
    expect do
      store.fetch(Struct.new(:foo).new(:bar), true)
    end.to raise_error(marshal_error)
  end

  it 'refuses to #[]= to keys that cannot be marshalled' do
    expect do
      store[Struct.new(:foo).new(:bar)] = 'value'
    end.to raise_error(marshal_error)
  end

  it 'refuses to store to keys that cannot be marshalled' do
    expect do
      store.store Struct.new(:foo).new(:bar), 'value'
    end.to raise_error(marshal_error)
  end

  it 'refuses to check for key? if the key cannot be marshalled' do
    expect do
      store.key? Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end

  it 'refuses to delete a key if the key cannot be marshalled' do
    expect do
      store.delete Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end
end

#################### marshallable_value ####################

shared_examples_for 'marshallable_value' do
  it 'refuses to store values that cannot be marshalled' do
    expect do
      store.store 'key', Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end
end

#################### transform_value ####################

shared_examples_for 'transform_value' do
  it 'allows to bypass transformer with :raw' do
    store['key'] = 'value'
    load_value(store.load('key', :raw => true)).should == 'value'

    store.store('key', 'value', :raw => true)
    store.load('key', :raw => true).should == 'value'
    store.delete('key', :raw => true).should == 'value'
  end

  it 'allows to bypass transformer with raw syntactic sugar' do
    store['key'] = 'value'
    load_value(store.raw.load('key')).should == 'value'

    store.raw.store('key', 'value')
    store.raw['key'].should == 'value'
    store.raw.load('key').should == 'value'
    store.raw.delete('key').should == 'value'

    store.raw['key'] = 'value2'
    store.raw['key'].should == 'value2'
  end

  it 'should return unmarshalled value' do
    store.store('key', 'unmarshalled value', :raw => true)
    store.load('key', :raw => true).should == 'unmarshalled value'
    store['key'].should == 'unmarshalled value'
    store.delete('key').should == 'unmarshalled value'
  end
end

#################### transform_value_with_expires ####################

shared_examples_for 'transform_value_with_expires' do
  it 'allows to bypass transformer with :raw' do
    store['key'] = 'value'
    load_value(store.load('key', :raw => true)).should == ['value']

    store.store('key', 'value', :expires => 10)
    load_value(store.load('key', :raw => true)).first.should == 'value'
    load_value(store.load('key', :raw => true)).last.should respond_to(:to_int)

    store.store('key', 'value', :raw => true)
    store.load('key', :raw => true).should == 'value'
    store.delete('key', :raw => true).should == 'value'
  end

  it 'should return unmarshalled value' do
    store.store('key', 'unmarshalled value', :raw => true)
    store.load('key', :raw => true).should == 'unmarshalled value'
    store['key'].should == 'unmarshalled value'
    store.delete('key').should == 'unmarshalled value'
  end
end

