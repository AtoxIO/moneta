{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"a unified interface to key/value stores","body":"# Moneta: A unified interface for key/value stores\r\n\r\n[![Build Status](https://secure.travis-ci.org/minad/moneta.png?branch=master)](http://travis-ci.org/minad/moneta) [![Dependency Status](https://gemnasium.com/minad/moneta.png?travis)](https://gemnasium.com/minad/moneta) [![Code Climate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/minad/moneta)\r\n\r\nMoneta provides a standard interface for interacting with various kinds of key/value stores. A short overview of the features:\r\n\r\n* Supports a lot of backends (See below)\r\n* Allows a full configuration of the serialization -> compression -> adapter stack using proxies (Similar to [Rack middlewares](http://rack.github.com/))\r\n    * Configurable serialization via `Moneta::Transformer` proxy (Marshal/JSON/YAML and many more)\r\n    * Configurable value compression via `Moneta::Transformer` proxy (Zlib, Snappy, LZMA, ...)\r\n    * Configurable key transformation via `Moneta::Transformer` proxy\r\n* Expiration for all stores (Added via proxy `Moneta::Expires` if not supported natively)\r\n* Atomic incrementation and decrementation for most stores (Method `#increment` and `#decrement`)\r\n* Includes a very simple key/value server (`Moneta::Server`) and client (`Moneta::Adapters::Client`)\r\n* Integration with [Rails](http://rubyonrails.org/), [Rack](http://rack.github.com/) as cookie and session store and [Rack-Cache](https://github.com/rtomayko/rack-cache)\r\n\r\nMoneta is tested thoroughly using [Travis-CI](http://travis-ci.org/minad/moneta).\r\n\r\n## Links\r\n\r\n* Source: <http://github.com/minad/moneta>\r\n* Bugs:   <http://github.com/minad/moneta/issues>\r\n* API documentation:\r\n    * Latest Gem: <http://rubydoc.info/gems/moneta/frames>\r\n    * GitHub master: <http://rubydoc.info/github/minad/moneta/master/frames>\r\n\r\n## Supported backends\r\n\r\nOut of the box, it supports the following backends:\r\n\r\n* Memory:\r\n    * In-memory store (`:Memory`)\r\n    * LRU hash - prefer this over :Memory! (`:LRUHash`)\r\n    * LocalMemCache (`:LocalMemCache`)\r\n    * Memcached store (`:Memcached`, `:MemcachedNative` and `:MemcachedDalli`)\r\n* Relational Databases:\r\n    * DataMapper (`:DataMapper`)\r\n    * ActiveRecord (`:ActiveRecord`)\r\n    * Sequel (`:Sequel`)\r\n    * Sqlite3 (`:Sqlite`)\r\n* Filesystem:\r\n    * PStore (`:PStore`)\r\n    * YAML store (`:YAML`)\r\n    * Filesystem directory store (`:File`)\r\n    * Filesystem directory store which spreads files in subdirectories using md5 hash (`:HashFile`)\r\n* Key/value databases:\r\n    * Berkeley DB (`:DBM`)\r\n    * Cassandra (`:Cassandra`)\r\n    * GDBM (`:GDBM`)\r\n    * HBase (`:HBase`)\r\n    * LevelDB (`:LevelDB`)\r\n    * Redis (`:Redis`)\r\n    * Riak (`:Riak`)\r\n    * SDBM (`:SDBM`)\r\n    * TokyoCabinet (`:TokyoCabinet`)\r\n* Document databases:\r\n    * CouchDB (`:Couch`)\r\n    * MongoDB (`:Mongo`)\r\n* Other\r\n    * Moneta key/value server client (`:Client` works with `Moneta::Server`)\r\n    * Fog cloud storage which supports Amazon S3, Rackspace, etc. (`:Fog`)\r\n    * Storage which doesn't store anything (`:Null`)\r\n\r\nSome of the backends are not exactly based on key/value stores, e.g. the relational ones. These\r\nare useful if you already use the corresponding backend in your application. You get a key/value\r\nstore for free then without installing any additional services and you still have the possibility\r\nto upgrade to a real key/value store.\r\n\r\n## Proxies\r\n\r\nIn addition it supports proxies (Similar to [Rack middlewares](http://rack.github.com/)) which\r\nadd additional features to storage backends:\r\n\r\n* `Moneta::Proxy` and `Moneta::Wrapper` proxy base classes\r\n* `Moneta::Expires` to add expiration support to stores which don't support it natively. Add it in the builder using `use :Expires`.\r\n* `Moneta::Stack` to stack multiple stores (Read returns result from first where the key is found, writes go to all stores). Add it in the builder using `use :Stack`.\r\n* `Moneta::Transformer` transforms keys and values (Marshal, YAML, JSON, Base64, MD5, ...). Add it in the builder using `use :Transformer`.\r\n* `Moneta::Cache` combine two stores, one as backend and one as cache (e.g. `Moneta::Adapters::File` + `Moneta::Adapters::Memory`). Add it in the builder using `use :Cache`.\r\n* `Moneta::Lock` to make store thread safe. Add it in the builder using `use :Lock`.\r\n* `Moneta::Logger` to log database accesses. Add it in the builder using `use :Logger`.\r\n* `Moneta::Shared` to share a store between multiple processes. Add it in the builder using `use :Shared`.\r\n\r\n## Supported serializers and compressors (`Moneta::Transformer`)\r\n\r\nSupported serializers:\r\n\r\n* BEncode (`:bencode`)\r\n* BERT (`:bert`)\r\n* BSON (`:bson`)\r\n* JSON (`:json`)\r\n* Marshal (`:marshal`)\r\n* MessagePack (`:msgpack`)\r\n* Ox (`:ox`)\r\n* TNetStrings (`:tnet`)\r\n* YAML (`:yaml`)\r\n\r\nSupported value compressors:\r\n\r\n* LZMA (`:lzma`)\r\n* LZO (`:lzo`)\r\n* Snappy (`:snappy`)\r\n* QuickLZ (`:quicklz`)\r\n* Zlib (`:zlib`)\r\n\r\nSpecial transformers:\r\n\r\n* Digests (MD5, Shas, ...)\r\n* Add prefix to keys (`:prefix`)\r\n* HMAC to verify values (`:hmac`, useful for `Rack::MonetaCookies`)\r\n\r\n## Moneta API\r\n\r\nThe Moneta API is purposely extremely similar to the Hash API with a few minor additions.\r\nThere are the additional methods `#load`, `#increment`, `#decrement` and `#close`. Every method takes also a optional\r\noption hash. In order so support an identical API across stores, Moneta does not support iteration or partial matches.\r\n\r\n~~~\r\n#initialize(options)                      options differs per-store, and is used to set up the store.\r\n\r\n#[](key)                                  retrieve a key. If the key is not available, return nil.\r\n\r\n#load(key, options = {})                  retrieve a key. If the key is not available, return nil.\r\n\r\n#fetch(key, options = {}, &block)         retrieve a key. If the key is not available, execute the\r\n                                          block and return its return value.\r\n\r\n#fetch(key, value, options = {})          retrieve a key. If the key is not available, return the value,\r\n\r\n#[]=(key, value)                          set a value for a key. If the key is already used, clobber it.\r\n                                          keys set using []= will never expire.\r\n\r\n#store(key, value, options = {})          same as []=, but you can supply options.\r\n\r\n#delete(key, options = {})                delete the key from the store and return the current value.\r\n\r\n#key?(key, options = {})                  true if the key exists, false if it does not.\r\n\r\n#increment(key, amount = 1, options = {}) increment numeric value. This is a atomic operation\r\n                                          which is not supported by all stores. Returns current value.\r\n\r\n#decrement(key, amount = 1, options = {}) increment numeric value. This is a atomic operation\r\n                                          which is not supported by all stores. Returns current value.\r\n                                          This is just syntactic sugar for incrementing with a negative value.\r\n\r\n#clear(options = {})                      clear all keys in this store.\r\n\r\n#close                                    close database connection.\r\n~~~\r\n\r\n### Creating a Store\r\n\r\nThere is a simple interface to create a store using `Moneta.new`:\r\n\r\n~~~ ruby\r\nstore = Moneta.new(:Memcached, :server => 'localhost:11211')\r\n~~~\r\n\r\nIf you want to have control over the proxies, you have to use `Moneta.build`:\r\n\r\n~~~ ruby\r\nstore = Moneta.build do\r\n  # Adds expires proxy\r\n  use :Expires\r\n  # Transform key using Marshal and Base64 and value using Marshal\r\n  use :Transformer, :key => [:marshal, :base64], :value => :marshal\r\n  # Memory backend\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n### Expiration\r\n\r\nThe Cassandra, Memcached and Redis backends supports expires values directly:\r\n\r\n~~~ ruby\r\ncache = Moneta::Adapters::Memcached.new\r\n\r\n# Or using the builder...\r\ncache = Moneta.build do\r\n  adapter :Memcached\r\nend\r\n\r\n# Expires in 60 seconds\r\ncache.store(key, value, :expires => 60)\r\n\r\n# Update expires time if value is found\r\ncache.load(key, :expires => 30)\r\ncache.key?(key, :expires => 30)\r\n~~~\r\n\r\nYou can add the expires feature to other backends using the Expires proxy:\r\n\r\n~~~ ruby\r\n# Using the :expires option\r\ncache = Moneta.new(:File, :dir => '...', :expires => true)\r\n\r\n# or manually by using the proxy...\r\ncache = Moneta::Expires.new(Moneta::Adapters::File.new(:dir => '...'))\r\n\r\n# or using the builder...\r\ncache = Moneta.build do\r\n  use :Expires\r\n  adapter :File, :dir => '...'\r\nend\r\n~~~\r\n\r\n### Incrementation and raw access\r\n\r\nThe stores support the `#increment` which allows atomic increments of unsigned integer values. If you increment\r\na non existing value, it will be created. If you increment a non integer value an exception will be raised.\r\n\r\n~~~ ruby\r\nstore.increment('counter')     # returns 1, counter created\r\nstore.increment('counter')     # returns 2\r\nstore.increment('counter', -1) # returns 1\r\nstore.increment('counter', 13) # returns 14\r\nstore.increment('counter', 0)  # returns 14\r\nstore.decrement('counter')     # returns 13\r\nstore['name'] = 'Moneta'\r\nstore.increment('name')        # raises an Exception\r\n~~~\r\n\r\nIf you want to access the counter value you have to use raw access to the datastore. This is only important\r\nif you have a `Moneta::Transformer` somewhere in your proxy stack which transforms the values e.g. with `Marshal`.\r\n\r\n~~~ ruby\r\nstore.increment('counter')          # returns 1, counter created\r\nstore.load('counter', :raw => true) # returns 1\r\n\r\nstore.store('counter', '10', :raw => true)\r\nstore.increment('counter') # returns 11\r\n~~~\r\n\r\nFortunately there is a nicer way to do this using some syntactic sugar!\r\n\r\n~~~ ruby\r\nstore.increment('counter') # returns 1, counter created\r\nstore.raw['counter']       # returns 1\r\nstore.raw.load('counter')  # returns 1\r\n\r\nstore.raw['counter'] = '10'\r\nstore.increment('counter') # returns 11\r\n~~~\r\n\r\nYou can also keep the `raw` store in a variable and use it like this:\r\n\r\n~~~ ruby\r\ncounters = store.raw\r\n\r\ncounters.increment('counter') # returns 1, counter created\r\ncounters['counter']           # returns 1\r\ncounters.load('counter')      # returns 1\r\n\r\ncounters['counter'] = '10'\r\ncounters.increment('counter') # returns 11\r\n~~~\r\n\r\nStores which support incrementation (you have to use `Moneta::Lock` if you want to use the store in a multithreading environment.)\r\n\r\n* ActiveRecord\r\n* File\r\n* HBase\r\n* LRUHash\r\n* LevelDB\r\n* Memcached\r\n* Memory\r\n* Redis\r\n* SDBM/DBM/GDBM\r\n* Sequel\r\n* Sqlite\r\n* TokyoCabinet\r\n* YAML/PStore\r\n\r\nStores which don't support incrementation:\r\n\r\n* Cassandra\r\n* Couch\r\n* DataMapper\r\n* Fog\r\n* LocalMemCache\r\n* Mongo\r\n* Riak\r\n\r\n### Syntactic sugar and option merger\r\n\r\nFor raw data access as described before the class `Moneta::OptionMerger` is used. It works like this:\r\n\r\n~~~ ruby\r\n# All methods after 'with' get the options passed\r\nstore.with(:raw => true).load('key')\r\n\r\n# You can also specify the methods\r\nstore.with(:raw => true, :only => :load).load('key')\r\nstore.with(:raw => true, :except => [:key?, :increment]).load('key')\r\n\r\n# Syntactic sugar for raw access\r\nstore.raw.load('key')\r\n\r\n# Access substore where all keys get a prefix\r\nsubstore = store.prefix('sub')\r\nsubstore['key'] = 'value'\r\nstore['key']    # returns nil\r\nstore['subkey'] # returns 'value'\r\n\r\n# Set expiration time for all keys\r\nshort_lived_store = store.expires(60)\r\nshort_lived_store['key'] = 'value'\r\n~~~\r\n\r\n## Framework Integration\r\n\r\nInspired by [redis-store](https://github.com/jodosha/redis-store) there exist integration classes for [Rails](http://rubyonrails.org/), [Rack](http://rack.github.com/) and [Rack-Cache](https://github.com/rtomayko/rack-cache).\r\n\r\n### Rack session store\r\n\r\nUse Moneta as a [Rack](http://rack.github.com/) session store:\r\n\r\n~~~ ruby\r\nrequire 'rack/session/moneta'\r\n\r\n# Use only the adapter name\r\nuse Rack::Session::Moneta, :store => :Redis\r\n\r\n# Use Moneta.new\r\nuse Rack::Session::Moneta, :store => Moneta.new(:Memory, :expires => true)\r\n\r\n# Use the Moneta builder\r\nuse Rack::Session::Moneta do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n### Rack cache\r\n\r\nUse Moneta as a [Rack-Cache](https://github.com/rtomayko/rack-cache) store:\r\n\r\n~~~ ruby\r\nrequire 'rack/cache/moneta'\r\n\r\nuse Rack::Cache,\r\n      :metastore   => 'moneta://Memory?expires=true',\r\n      :entitystore => 'moneta://Memory?expires=true'\r\n\r\n# Or used named Moneta stores\r\nRack::Cache::Moneta['named_metastore'] = Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\nuse Rack::Cache,\r\n      :metastore => 'moneta://named_metastore',\r\n      :entity_store => 'moneta://named_entitystore'\r\n~~~\r\n\r\n### Rack cookies\r\n\r\nUse Moneta to store cookies in [Rack](http://rack.github.com/). It uses the `Moneta::Adapters::Cookie`. You might\r\nwonder what the purpose of this store or Rack middleware is: It makes it possible\r\nto use all the transformers on the cookies (e.g. `:prefix`, `:marshal` and `:hmac` for value verification).\r\n\r\n~~~ ruby\r\nrequire 'rack/moneta_cookies'\r\n\r\nuse Rack::MonetaCookies, :domain => 'example.com', :path => '/path'\r\nrun lambda do |env|\r\n  req = Rack::Request.new(env)\r\n  req.cookies #=> is now a Moneta store!\r\n  env['rack.request.cookie_hash'] #=> is now a Moneta store!\r\n  req.cookies['key'] #=> retrieves 'key'\r\n  req.cookies['key'] = 'value' #=> sets 'key'\r\n  req.cookies.delete('key') #=> removes 'key'\r\n  [200, {}, []]\r\nend\r\n~~~\r\n\r\n### Rails session store\r\n\r\nAdd the session store in your application configuration `config/environments/*.rb`.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\n# Only by adapter name\r\nconfig.cache_store :moneta_store, :store => :Memory\r\n\r\n# Use Moneta.new\r\nconfig.cache_store :moneta_store, :store => Moneta.new(:Memory)\r\n\r\n# Use the Moneta builder\r\nconfig.cache_store :moneta_store, :store => Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n### Rails cache store\r\n\r\nAdd the cache store in your application configuration `config/environments/*.rb`. Unfortunately the\r\nMoneta cache store doesn't support matchers. If you need these features use a different server-specific implementation.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\n# Only by adapter name\r\nconfig.cache_store :moneta_store, :store => :Memory\r\n\r\n# Use Moneta.new\r\nconfig.cache_store :moneta_store, :store => Moneta.new(:Memory)\r\n\r\n# Use the Moneta builder\r\nconfig.cache_store :moneta_store, :store => Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n## Advanced\r\n\r\n### Build your own key value server\r\n\r\nYou can use Moneta to build your own key/value server which is shared between\r\nmultiple processes. If you run the following code in two different processes,\r\nthey will share the same data which will also be persistet in the database `shared.db`.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\nstore = Moneta.build do\r\n  use :Transformer, :key => :marshal, :value => :marshal\r\n  use :Shared do\r\n    use :Cache do\r\n      cache do\r\n        adapter :LRUHash\r\n      end\r\n      backend do\r\n        adapter :GDBM, :file => 'shared.db'\r\n      end\r\n    end\r\n  end\r\nend\r\n~~~\r\n\r\nIf you want to go further, you might want to take a look at `Moneta::Server` and `Moneta::Adapters::Client` which\r\nare used by `Moneta::Shared` and provide the networking communication. But be aware that they are experimental\r\nand subjected to change. They provide an acceptable performance (for being ruby only), but don't have a stable protocol yet.\r\n\r\nYou might wonder why I didn't use [DRb](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/drb/rdoc/DRb.html) to implement server and client -\r\nin fact my first versions used it, but with much worse performance and it was real fun to implement the networking directly :)\r\nThere is still much room for improvement and experiments, try [EventMachine](http://eventmachine.rubyforge.org/),\r\ntry [Kgio](http://bogomips.org/kgio/), ...\r\n\r\n### ToyStore ORM\r\n\r\nIf you want something more advanced to handle your objects and relations,\r\nuse John Nunemaker's [ToyStore](https://github.com/jnunemaker/toystore) which works\r\ntogether with Moneta. Assuming that `Person` is a `ToyStore::Object` you can\r\nadd persistence using Moneta as follows:\r\n\r\n~~~ ruby\r\n# Use the Moneta Redis backend\r\nPerson.adapter :memory, Moneta.new(:Redis)\r\n~~~\r\n\r\n## Testing and Benchmarks\r\n\r\nTesting is done using [Travis-CI](http://travis-ci.org/minad/moneta). Currently we support Ruby 1.8.7 and 1.9.3.\r\n\r\nBenchmarks for each store are done on [Travis-CI](http://travis-ci.org/minad/moneta) for each build. Take a look there\r\nto compare the speed of the different key value stores for different key/value sizes and size distributions.\r\nFeel free to add your own configurations! The impact of Moneta should be minimal since it is only a thin layer\r\non top of the different stores.\r\n\r\n## More information\r\n\r\n* http://yehudakatz.com/2009/02/12/whats-the-point/\r\n* http://yehudakatz.com/2009/02/12/initial-release-of-moneta-unified-keyvalue-store-api/\r\n\r\n## Alternatives\r\n\r\n* [Horcrux](https://github.com/technoweenie/horcrux): Used at github, supports batch operations but only Memcached backend\r\n* [ToyStore](https://github.com/jnunemaker/toystore): ORM mapper for key/value stores\r\n* [ToyStore Adapter](https://github.com/jnunemaker/adapter): Adapter to key/value stores used by ToyStore, Moneta can be used directly with the ToyStore Memory adapter\r\n\r\n## Authors\r\n\r\n* Daniel Mendler\r\n* Hannes Georg\r\n* Originally by Yehuda Katz and contributors\r\n","name":"Moneta","google":""}