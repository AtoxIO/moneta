{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Moneta: A unified interface for key/value stores\r\n\r\n[![Gem Version](https://badge.fury.io/rb/moneta.png)](http://rubygems.org/gems/moneta) [![Build Status](https://secure.travis-ci.org/minad/moneta.png?branch=master)](http://travis-ci.org/minad/moneta) [![Dependency Status](https://gemnasium.com/minad/moneta.png?travis)](https://gemnasium.com/minad/moneta) [![Code Climate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/minad/moneta)\r\n\r\nMoneta provides a standard interface for interacting with various kinds of key/value stores. A short overview of the features:\r\n\r\n* Supports a lot of backends with consistent behaviour (See below)\r\n* Allows a full configuration of the serialization -> compression -> adapter stack using proxies (Similar to [Rack middlewares](http://rack.github.com/))\r\n    * Configurable serialization via `Moneta::Transformer` proxy (Marshal/JSON/YAML and many more)\r\n    * Configurable value compression via `Moneta::Transformer` proxy (Zlib, Snappy, LZMA, ...)\r\n    * Configurable key transformation via `Moneta::Transformer` proxy\r\n* Expiration for all stores (Added via proxy `Moneta::Expires` if not supported natively)\r\n* Atomic operations\r\n    * Atomic incrementation and decrementation for most stores (Method `#increment` and `#decrement`)\r\n    * Atomic creation of entries (Method `#create`)\r\n    * Shared/distributed database-wide synchronization primitives `Moneta::Mutex` and `Moneta::Semaphore`\r\n* Includes a simple pure-ruby key/value server (`Moneta::Server`) and client (`Moneta::Adapters::Client`)\r\n* Integration with [Rails](http://rubyonrails.org/), [Rack](http://rack.github.com/)/[Rack-Cache](https://github.com/rtomayko/rack-cache), [Sinatra](http://sinatrarb.com/) and [Ramaze](http://ramaze.net/).\r\n\r\nIf you are not yet convinced, you might ask why? What are the goals of the project?\r\n\r\n* Get people started quickly with key/value stores! Therefore all the adapters are included in the gem and you are ready to go. [Tilt](https://github.com/rtomayko/tilt) does the\r\nsame for template languages.\r\n* Make it easy to compare different key/value stores and benchmark them\r\n* To hide a lot of different and maybe complex APIs behind one well-designed and simple Moneta API\r\n* Give people a starting point or example code to start working with their favourite key/value store. Feel free to copy code, please mention Moneta then :)\r\n* Create a reusable piece of code, since similar things are solved over and over again ([Rails](http://rubyonrails.org/) brings its own cache stores, and many frameworks do the same...)\r\n* See also http://yehudakatz.com/2009/02/12/whats-the-point/\r\n\r\nMoneta is tested thoroughly using [Travis-CI](http://travis-ci.org/minad/moneta).\r\n\r\n------\r\n\r\n## Getting started\r\n\r\nInstall Moneta via Rubygems\r\n\r\n~~~\r\n$ gem install moneta\r\n~~~\r\n\r\nor add it to your Gemfile\r\n\r\n~~~ ruby\r\ngem 'moneta'\r\n~~~\r\n\r\nNow you are ready to go:\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\n# Create a simple file store\r\nstore = Moneta.new(:File, :dir => 'moneta')\r\n\r\n# Store some entries\r\nstore['key'] = 'value'\r\n\r\n# Read entry\r\nstore.key?('key') # returns true\r\nstore['key'] # returns 'value'\r\n\r\nstore.close\r\n~~~\r\n\r\n------\r\n\r\n## Links\r\n\r\n* Source: <http://github.com/minad/moneta>\r\n* Bugs:   <http://github.com/minad/moneta/issues>\r\n* API documentation:\r\n    * Latest Gem: <http://rubydoc.info/gems/moneta/frames>\r\n    * GitHub master: <http://rubydoc.info/github/minad/moneta/master/frames>\r\n\r\n------\r\n\r\n## Supported backends\r\n\r\nOut of the box, it supports the following backends. Use the backend name symbol in the Moneta constructor (e.g. `Moneta.new(:Memory)`).\r\n\r\n* Memory:\r\n    * In-memory store (`:Memory`)\r\n    * LRU hash - prefer this over :Memory! (`:LRUHash`)\r\n    * [LocalMemCache](http://localmemcache.rubyforge.org/) (`:LocalMemCache`)\r\n    * [Memcached](http://memcached.org/) store (`:Memcached`, `:MemcachedNative` and `:MemcachedDalli`)\r\n* Relational Databases:\r\n    * [DataMapper](http://datamapper.org/) (`:DataMapper`)\r\n    * [ActiveRecord](https://rubygems.org/gems/activerecord) (`:ActiveRecord`)\r\n    * [Sequel](http://sequel.rubyforge.org/) (`:Sequel`)\r\n    * [Sqlite3](http://sqlite.org/) (`:Sqlite`)\r\n* Filesystem:\r\n    * [PStore](http://ruby-doc.org/stdlib/libdoc/pstore/rdoc/PStore.html) (`:PStore`)\r\n    * [YAML](http://www.ruby-doc.org/stdlib/libdoc/yaml/rdoc/YAML/Store.html) store (`:YAML`)\r\n    * Filesystem directory store (`:File`)\r\n    * Filesystem directory store which spreads files in subdirectories using md5 hash (`:HashFile`)\r\n* Key/value databases:\r\n    * [Berkeley DB](http://www.ruby-doc.org/stdlib/libdoc/dbm/rdoc/DBM.html) (`:DBM`)\r\n    * [Cassandra](http://cassandra.apache.org/) (`:Cassandra`)\r\n    * [Daybreak](http://propublica.github.com/daybreak/) (`:Daybreak`)\r\n    * [GDBM](http://www.ruby-doc.org/stdlib/libdoc/gdbm/rdoc/GDBM.html) (`:GDBM`)\r\n    * [HBase](http://hbase.apache.org/) (`:HBase`)\r\n    * [LevelDB](http://code.google.com/p/leveldb/) (`:LevelDB`)\r\n    * [Redis](http://redis.io/) (`:Redis`)\r\n    * [Riak](http://docs.basho.com/) (`:Riak`)\r\n    * [SDBM](http://www.ruby-doc.org/stdlib/libdoc/sdbm/rdoc/SDBM.html) (`:SDBM`)\r\n    * [KyotoCabinet](http://fallabs.com/kyotocabinet/) (`:KyotoCabinet`)\r\n    * [TokyoCabinet](http://fallabs.com/tokyocabinet/) (`:TokyoCabinet`)\r\n    * [Simple Samba database TDB](http://tdb.samba.org/) (`:TDB`)\r\n* Document databases:\r\n    * [CouchDB](http://couchdb.apache.org/) (`:Couch`)\r\n    * [MongoDB](http://www.mongodb.org/) (`:Mongo`)\r\n* Moneta network protocols:\r\n    * Moneta key/value client (`:Client` works with `Moneta::Server`)\r\n    * Moneta HTTP/REST client (`:RestClient` works with `Rack::MonetaRest`)\r\n* Other\r\n    * [Fog](http://fog.io/) cloud storage which supports Amazon S3, Rackspace, etc. (`:Fog`)\r\n    * Storage which doesn't store anything (`:Null`)\r\n\r\nSome of the backends are not exactly based on key/value stores, e.g. the relational ones. These\r\nare useful if you already use the corresponding backend in your application. You get a key/value\r\nstore for free then without installing any additional services and you still have the possibility\r\nto upgrade to a real key/value store.\r\n\r\n### Backend feature matrix\r\n\r\n__NOTE:__ <a name=\"backend-matrix\">The backend matrix</a> is much more readable on rubydoc.info than on github. [Go there!](http://rubydoc.info/github/minad/moneta/master/file/README.md#backend-matrix)\r\n\r\n<table>\r\n\r\n<tr><th>Adapter</th><th>Required gems</th><th>Multi-thread safe<sup>[1]</sup></th><th>Multi-process safe<sup>[2]</sup></th><th>Atomic increment<sup>[8]</sup></th><th>Atomic create<sup>[9]</sup></th><th>Native expires<sup>[3]</sup></th><th>Persistent</th><th>Description</th></tr>\r\n\r\n<tr><th colspan=\"2\">Persistent stores</th><th colspan=\"7\"></th></tr>\r\n\r\n<tr><td>Mongo</td><td>mongo</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://www.mongodb.org/\">MongoDB</a> database</td></tr>\r\n\r\n<tr><td>Redis</td><td>redis</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://redis.io/\">Redis</a> database</td></tr>\r\n\r\n<tr><td>ActiveRecord</td><td>activerecord</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"https://rubygems.org/gems/activerecord\">ActiveRecord</a> ORM</td></tr>\r\n\r\n<tr><td>File</td><td>-</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td>File store</td></tr>\r\n\r\n<tr><td>Sequel</td><td>sequel</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://sequel.rubyforge.org/\">Sequel</a> ORM</td></tr>\r\n\r\n<tr><td>Sqlite</td><td>sqlite3</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://sqlite.org/\">Sqlite3</a> database</td></tr>\r\n\r\n<tr><td>PStore</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://ruby-doc.org/stdlib/libdoc/pstore/rdoc/PStore.html\">PStore</a> store</td></tr>\r\n\r\n<tr><td>YAML</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://www.ruby-doc.org/stdlib/libdoc/yaml/rdoc/YAML/Store.html\">YAML</a> store</td></tr>\r\n\r\n<tr><td>Daybreak</td><td>daybreak</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#55F\">(✓)<sup>[7]</sup></td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td>Incredibly fast pure-ruby key/value store <a href=\"http://propublica.github.com/daybreak/\">Daybreak</a></td></tr>\r\n\r\n<tr><td>DBM</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://www.ruby-doc.org/stdlib/libdoc/dbm/rdoc/DBM.html\">Berkeley DB</a></td></tr>\r\n\r\n<tr><td>GDBM</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://www.ruby-doc.org/stdlib/libdoc/gdbm/rdoc/GDBM.html\">GDBM</a> database</td></tr>\r\n\r\n<tr><td>LevelDB</td><td>leveldb</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://code.google.com/p/leveldb/\">LevelDB</a> database</td></tr>\r\n\r\n<tr><td>SDBM</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://www.ruby-doc.org/stdlib/libdoc/sdbm/rdoc/SDBM.html\">SDBM</a> database</td></tr>\r\n\r\n<tr><td>TDB</td><td>tdb</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://tdb.samba.org/\">TDB</a> database</td></tr>\r\n\r\n<tr><td>KyotoCabinet</td><td>tokoycabinet</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://fallabs.com/kyotocabinet/\">KyotoCabinet</a> database</td></tr>\r\n\r\n<tr><td>TokyoCabinet</td><td>tokoycabinet</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://fallabs.com/tokyocabinet/\">TokyoCabinet</a> database</td></tr>\r\n\r\n<tr><td>DataMapper</td><td>dm-core, dm-migrations</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://datamapper.org/\">DataMapper</a> ORM</td></tr>\r\n\r\n<tr><td>Cassandra</td><td>cassandra</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://cassandra.apache.org/\">Cassandra</a> distributed database</td></tr>\r\n\r\n<tr><td>LocalMemCache</td><td>localmemcache</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://localmemcache.rubyforge.org/\">LocalMemCache</a> database</td></tr>\r\n\r\n<tr><td>Couch</td><td>couchrest</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://couchdb.apache.org/\">CouchDB</a> database</td></tr>\r\n\r\n<tr><td>Fog</td><td>fog</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://fog.io/\">Fog</a> cloud store</td></tr>\r\n\r\n<tr><td>HBase</td><td>hbase</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://hbase.apache.org/\">HBase</a> database</td></tr>\r\n\r\n<tr><td>Riak</td><td>riak-client</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td><a href=\"http://docs.basho.com/\">Riak</a> database</td></tr>\r\n\r\n<tr><th colspan=\"2\">Non persistent stores</th><th colspan=\"7\"></th></tr>\r\n\r\n<tr><td>MemcachedDalli</td><td>dalli</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗<sup>[4]</sup></td><td><a href=\"http://memcached.org/\">Memcached</a> database with Dalli library</td></tr>\r\n\r\n<tr><td>Memcached</td><td>dalli or memcached</td><td style=\"text-align:center;background:#55F\">?</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗<sup>[4]</sup></td><td><a href=\"http://memcached.org/\">Memcached</a> database</td></tr>\r\n\r\n<tr><td>MemcachedNative</td><td>memcached</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗<sup>[4]</sup></td><td>Memcached database with native library</td></tr>\r\n\r\n<tr><td>Cookie</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#55F\">(✓)<sup>[6]</sup></td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td>Cookie in memory store</td></tr>\r\n\r\n<tr><td>LRUHash</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#55F\">(✓)<sup>[6]</sup></td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td>LRU memory store</td></tr>\r\n\r\n<tr><td>Memory</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#55F\">(✓)<sup>[6]</sup></td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td>Memory store</td></tr>\r\n\r\n<tr><td>Null</td><td>-</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td>No database</td></tr>\r\n\r\n<tr><td>Client</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#55F\">?<sup>[5]</sup></td><td style=\"text-align:center;background:#55F\">?<sup>[5]</sup></td><td style=\"text-align:center;background:#55F\">?<sup>[5]</sup></td><td style=\"text-align:center;background:#55F\">?<sup>[5]</sup></td><td>Moneta client adapter</td></tr>\r\n\r\n<tr><td>RestClient</td><td>-</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#5F5\">✓</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#F44\">✗</td><td style=\"text-align:center;background:#55F\">?<sup>[5]</sup></td><td>Moneta REST client adapter</td></tr>\r\n\r\n</table>\r\n\r\n* [1]: Make adapters thread-safe by using `Moneta::Lock` or by passing the option `:threadsafe => true` to `Moneta#new`. There is also `Moneta::Pool` which can be used to share a store between multiple threads if the store is multi-process safe. I recommend to add the option `:threadsafe` to ensure thread-safety since for example under JRuby and Rubinius even the basic datastructures are not thread safe due to the lack of a global interpreter lock (GIL). This differs from MRI where some adapters might appear thread safe already but only due to the GIL.\r\n* [2]: Share a Moneta store between multiple processes using `Moneta::Shared` (See below).\r\n* [3]: Add expiration support by using `Moneta::Expires` or by passing the option `:expires => true` to `Moneta#new`.\r\n* [4]: There are some servers which use the memcached protocol but which are persistent (e.g. [MemcacheDB](http://memcachedb.org/), [Kai](http://sourceforge.net/apps/mediawiki/kai), [IronCache](http://dev.iron.io/cache/reference/memcache/), [Roma](https://github.com/roma/roma/tree))\r\n* [5]: Depends on server\r\n* [6]: Store is multi-process safe because it is an in-memory store, values are not shared between multiple processes\r\n* [7]: Store is multi-process safe, but not synchronized automatically between multiple processes\r\n* [8]: If a store provides atomic increment it can be used with `Moneta::Semaphore`. You can add weak `#increment` using the `Moneta::WeakIncrement` proxy.\r\n* [8]: If a store provides atomic creation it can be used with `Moneta::Mutex`. You can add weak `#create` using the `Moneta::WeakCreate` proxy.\r\n\r\n------\r\n\r\n## Proxies\r\n\r\nIn addition it supports proxies (Similar to [Rack middlewares](http://rack.github.com/)) which\r\nadd additional features to storage backends:\r\n\r\n* `Moneta::Proxy` and `Moneta::Wrapper` proxy base classes\r\n* `Moneta::Expires` to add expiration support to stores which don't support it natively. Add it in the builder using `use :Expires`.\r\n* `Moneta::Stack` to stack multiple stores (Read returns result from first where the key is found, writes go to all stores). Add it in the builder using `use(:Stack) {}`.\r\n* `Moneta::Transformer` transforms keys and values (Marshal, YAML, JSON, Base64, MD5, ...). Add it in the builder using `use :Transformer`.\r\n* `Moneta::Cache` combine two stores, one as backend and one as cache (e.g. `Moneta::Adapters::File` + `Moneta::Adapters::Memory`). Add it in the builder using `use(:Cache) {}`.\r\n* `Moneta::Lock` to make store thread safe. Add it in the builder using `use :Lock`.\r\n* `Moneta::Pool` to create a pool of stores as a means of making the store thread safe. Add it in the builder using `use(:Pool) {}`.\r\n* `Moneta::Logger` to log database accesses. Add it in the builder using `use :Logger`.\r\n* `Moneta::Shared` to share a store between multiple processes. Add it in the builder using `use(:Shared) {}`.\r\n* `Moneta::WeakIncrement` and `Moneta::WeakCreate` to add `#create` and `#increment` support without atomicity (weak) to stores which don't support it.\r\n\r\n### Serializers and compressors (`Moneta::Transformer`)\r\n\r\nSupported serializers:\r\n\r\n* BEncode (`:bencode`)\r\n* BERT (`:bert`)\r\n* BSON (`:bson`)\r\n* JSON (`:json`)\r\n* Marshal (`:marshal`)\r\n* MessagePack (`:msgpack`)\r\n* Ox (`:ox`)\r\n* TNetStrings (`:tnet`)\r\n* YAML (`:yaml`)\r\n\r\nSupported value compressors:\r\n\r\n* LZMA (`:lzma`)\r\n* LZO (`:lzo`)\r\n* Snappy (`:snappy`)\r\n* QuickLZ (`:quicklz`)\r\n* Zlib (`:zlib`)\r\n\r\nSpecial transformers:\r\n\r\n* Digests (MD5, Shas, ...)\r\n* Add prefix to keys (`:prefix`)\r\n* HMAC to verify values (`:hmac`, useful for `Rack::MonetaCookies`)\r\n\r\n------\r\n\r\n## Moneta API\r\n\r\nThe Moneta API is purposely extremely similar to the Hash API with a few minor additions.\r\nThere are the additional methods `#load`, `#increment`, `#decrement`, `#create` and `#close`. Every method takes also a optional\r\noption hash. In order so support an identical API across stores, Moneta does not support iteration or partial matches.\r\n\r\n~~~\r\n#initialize(options)                      options differs per-store, and is used to set up the store.\r\n\r\n#[](key)                                  retrieve a key. If the key is not available, return nil.\r\n\r\n#load(key, options = {})                  retrieve a key. If the key is not available, return nil.\r\n\r\n#fetch(key, options = {}, &block)         retrieve a key. If the key is not available, execute the\r\n                                          block and return its return value.\r\n\r\n#fetch(key, value, options = {})          retrieve a key. If the key is not available, return the value,\r\n\r\n#[]=(key, value)                          set a value for a key. If the key is already used, clobber it.\r\n                                          keys set using []= will never expire.\r\n\r\n#store(key, value, options = {})          same as []=, but you can supply options.\r\n\r\n#delete(key, options = {})                delete the key from the store and return the current value.\r\n\r\n#key?(key, options = {})                  true if the key exists, false if it does not.\r\n\r\n#increment(key, amount = 1, options = {}) increment numeric value. This is an atomic operation\r\n                                          which is not supported by all stores. Returns current value.\r\n\r\n#decrement(key, amount = 1, options = {}) increment numeric value. This is an atomic operation\r\n                                          which is not supported by all stores. Returns current value.\r\n                                          This is just syntactic sugar for incrementing with a negative value.\r\n\r\n#create(key, value, options = {})         create entry. This is an atomic operation which is not supported by all stores.\r\n                                          Returns true if the value was created.\r\n\r\n#clear(options = {})                      clear all keys in this store.\r\n\r\n#close                                    close database connection.\r\n~~~\r\n\r\n### Creating a Store\r\n\r\nThere is a simple interface to create a store using `Moneta.new`:\r\n\r\n~~~ ruby\r\nstore = Moneta.new(:Memcached, :server => 'localhost:11211')\r\n~~~\r\n\r\nIf you want to have control over the proxies, you have to use `Moneta.build`:\r\n\r\n~~~ ruby\r\nstore = Moneta.build do\r\n  # Adds expires proxy\r\n  use :Expires\r\n  # Transform key using Marshal and Base64 and value using Marshal\r\n  use :Transformer, :key => [:marshal, :base64], :value => :marshal\r\n  # Memory backend\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n### Expiration\r\n\r\nThe Cassandra, Memcached, Redis and Mongo backends support expiration natively.\r\n\r\n~~~ ruby\r\ncache = Moneta::Adapters::Memcached.new\r\n\r\n# Or using the builder...\r\ncache = Moneta.build do\r\n  adapter :Memcached\r\nend\r\n\r\n# Expires in 60 seconds\r\ncache.store(key, value, :expires => 60)\r\n\r\n# Never expire\r\ncache.store(key, value, :expires => 0)\r\ncache.store(key, value, :expires => false)\r\n\r\n# Update expires time if value is found\r\ncache.load(key, :expires => 30)\r\ncache.key?(key, :expires => 30)\r\n\r\n# Or remove the expiration if found\r\ncache.load(key, :expires => false)\r\ncache.key?(key, :expires => 0)\r\n~~~\r\n\r\nYou can add the expires feature to other backends using the `Moneta::Expires` proxy. But be aware\r\nthat expired values are not deleted automatically if they are not looked up.\r\n\r\n~~~ ruby\r\n# Using the :expires option\r\ncache = Moneta.new(:File, :dir => '...', :expires => true)\r\n\r\n# or manually by using the proxy...\r\ncache = Moneta::Expires.new(Moneta::Adapters::File.new(:dir => '...'))\r\n\r\n# or using the builder...\r\ncache = Moneta.build do\r\n  use :Expires\r\n  adapter :File, :dir => '...'\r\nend\r\n~~~\r\n\r\n### Atomic operations\r\n\r\n#### Atomic incrementation and raw access\r\n\r\nThe stores support the `#increment` which allows atomic increments of unsigned integer values. If you increment\r\na non existing value, it will be created. If you increment a non integer value an exception will be raised.\r\n\r\n~~~ ruby\r\nstore.increment('counter')     # returns 1, counter created\r\nstore.increment('counter')     # returns 2\r\nstore.increment('counter', -1) # returns 1\r\nstore.increment('counter', 13) # returns 14\r\nstore.increment('counter', 0)  # returns 14\r\nstore.decrement('counter')     # returns 13\r\nstore['name'] = 'Moneta'\r\nstore.increment('name')        # raises an Exception\r\n~~~\r\n\r\nIf you want to access the counter value you have to use raw access to the datastore. This is only important\r\nif you have a `Moneta::Transformer` somewhere in your proxy stack which transforms the values e.g. with `Marshal`.\r\n\r\n~~~ ruby\r\nstore.increment('counter')          # returns 1, counter created\r\nstore.load('counter', :raw => true) # returns 1\r\n\r\nstore.store('counter', '10', :raw => true)\r\nstore.increment('counter') # returns 11\r\n~~~\r\n\r\nFortunately there is a nicer way to do this using some syntactic sugar!\r\n\r\n~~~ ruby\r\nstore.increment('counter') # returns 1, counter created\r\nstore.raw['counter']       # returns 1\r\nstore.raw.load('counter')  # returns 1\r\n\r\nstore.raw['counter'] = '10'\r\nstore.increment('counter') # returns 11\r\n~~~\r\n\r\nYou can also keep the `raw` store in a variable and use it like this:\r\n\r\n~~~ ruby\r\ncounters = store.raw\r\n\r\ncounters.increment('counter') # returns 1, counter created\r\ncounters['counter']           # returns 1\r\ncounters.load('counter')      # returns 1\r\n\r\ncounters['counter'] = '10'\r\ncounters.increment('counter') # returns 11\r\n~~~\r\n\r\n#### Atomic create\r\n\r\nThe stores support the `#create` which allows atomic creation of entries. `#create` returns true\r\nif the value was created.\r\n\r\n~~~ ruby\r\nstore.create('key', 'value') # returns true\r\nstore.create('key', 'other value') # returns false\r\n~~~\r\n\r\n#### Shared/distributed synchronization primitives\r\n\r\nMoneta provides shared/distributed synchronization primitives which are shared database-wide between\r\nall clients.\r\n\r\n`Moneta::Mutex` allows a single thread to enter a critical section.\r\n\r\n~~~ ruby\r\nmutex = Moneta::Mutex.new(store, 'mutex_key')\r\n\r\nmutex.synchronize do\r\n   mutex.locked? # returns true\r\n\r\n   # Synchronized access to counter\r\n   store['counter'] += 1\r\nend\r\n\r\nbegin\r\n  mutex.lock\r\n  mutex.locked? # returns true\r\n  ...\r\nensure\r\n  mutex.unlock\r\nend\r\n~~~\r\n\r\n`Moneta::Semaphore` allows `max_concurrent` threads to enter a critical section.\r\n\r\n~~~ ruby\r\nsemaphore = Moneta::Semaphore.new(store, 'semaphore_counter', max_concurrent)\r\n\r\nsemaphore.synchronize do\r\n   semaphore.locked? # returns true\r\n   ...\r\nend\r\n\r\nbegin\r\n  semaphore.enter\r\n  semaphore.locked? # returns true\r\n  ...\r\nensure\r\n  semaphore.leave\r\nend\r\n~~~\r\n\r\n#### Weak atomic operations\r\n\r\nIf an underlying adapter doesn't provide atomic `#create` or `#increment` and `#decrement` you can\r\nuse the proxies `Moneta::WeakIncrement` and `Moneta::WeakCreate` to add support without atomicity.\r\n\r\nBut then you have to ensure that the store is not shared by multiple processes and thread-safety is\r\nprovided by `Moneta::Lock`.\r\n\r\n### Syntactic sugar and option merger\r\n\r\nFor raw data access as described before the class `Moneta::OptionMerger` is used. It works like this:\r\n\r\n~~~ ruby\r\n# All methods after 'with' get the options passed\r\nstore.with(:raw => true).load('key')\r\n\r\n# You can also specify the methods\r\nstore.with(:raw => true, :only => :load).load('key')\r\nstore.with(:raw => true, :except => [:key?, :increment]).load('key')\r\n\r\n# Syntactic sugar for raw access\r\nstore.raw.load('key')\r\n\r\n# Access substore where all keys get a prefix\r\nsubstore = store.prefix('sub')\r\nsubstore['key'] = 'value'\r\nstore['key']    # returns nil\r\nstore['subkey'] # returns 'value'\r\n\r\n# Set expiration time for all keys\r\nshort_lived_store = store.expires(60)\r\nshort_lived_store['key'] = 'value'\r\n~~~\r\n\r\n### Add proxies to existing store\r\n\r\nYou can add proxies to an existing store. This is useful if you want to compress only a few values for example.\r\n\r\n~~~ ruby\r\ncompressed_store = store.with(:prefix => 'compressed') do\r\n  use :Transformer, :value => :zlib\r\nend\r\n\r\nstore['key'] = 'this value will not be compressed'\r\ncompressed_store['key'] = 'value will be compressed'\r\n~~~\r\n\r\n------\r\n\r\n## Framework Integration\r\n\r\nInspired by [redis-store](https://github.com/jodosha/redis-store) there exist integration classes for [Rails](http://rubyonrails.org/) and [Rack](http://rack.github.com/)/[Rack-Cache](https://github.com/rtomayko/rack-cache). You can also use all the Rack middlewares together with Rails and the [Sinatra](http://sinatrarb.com/) framework. There exist the following integration classes:\r\n\r\n* Rack, Rails and Sinatra\r\n    * `Rack::Session::Moneta` is a Rack middleware to use Moneta for storing sessions\r\n    * `Rack::MonetaStore` is a Rack middleware which places a Moneta store in the environment and enables per-request caching\r\n    * `Rack::MonetaCookies` is a Rack middleware which uses Moneta to store cookies\r\n    * `Rack::MonetaRest` is a Rack application which exposes a Moneta store via REST/HTTP\r\n    * `Rack::Cache::Moneta` provides meta and entity stores for Rack-Cache\r\n* Rails\r\n    * `ActionDispatch::Session::MonetaStore` is a Rails middleware to use Moneta for storing sessions\r\n    * `ActiveSupport::Cache::MonetaStore` is a Rails cache implementation which uses a Moneta store as backend\r\n* Ramaze\r\n    * `Ramaze::Cache::Moneta` is integrated into the [Ramaze](http://ramaze.net/) project and allows Ramaze to use\r\n      Moneta as caching store\r\n\r\n### Rack\r\n\r\n#### Session store\r\n\r\nYou can use Moneta as a [Rack](http://rack.github.com/) session store. Use it in your `config.ru` like this:\r\n\r\n~~~ ruby\r\nrequire 'rack/session/moneta'\r\n\r\n# Use only the adapter name\r\nuse Rack::Session::Moneta, :store => :Redis\r\n\r\n# Use Moneta.new\r\nuse Rack::Session::Moneta, :store => Moneta.new(:Memory, :expires => true)\r\n\r\n# Use the Moneta builder\r\nuse Rack::Session::Moneta do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n#### Moneta middleware\r\n\r\nThere is a simple middleware which places a Moneta store in the Rack environment at `env['rack.moneta_store']`. It supports per-request\r\ncaching if you add the option `:cache => true`. Use it in your `config.ru` like this:\r\n\r\n~~~ ruby\r\n# Add Rack::MonetaStore somewhere in your rack stack\r\nuse Rack::MonetaStore, :Memory, :cache => true\r\n\r\nrun lambda { |env|\r\n  env['rack.moneta_store'] # is a Moneta store with per-request caching\r\n}\r\n\r\n# Pass it a block like the one passed to Moneta.build\r\nuse Rack::MonetaStore do\r\n  use :Transformer, :value => :zlib\r\n  adapter :Cookie\r\nend\r\n\r\nrun lambda { |env|\r\n  env['rack.moneta_store'] # is a Moneta store without caching\r\n}\r\n~~~\r\n\r\n#### REST server\r\n\r\nIf you want to expose your Moneta key/value store via HTTP, you can use the Rack/Moneta REST service. Use it in your `config.ru` like this:\r\n\r\n~~~ ruby\r\nrequire 'rack/moneta_rest'\r\n\r\nmap '/moneta' do\r\n  run Rack::MonetaRest.new(:Memory)\r\nend\r\n\r\n# Or pass it a block like the one passed to Moneta.build\r\nrun Rack::MonetaRest.new do\r\n  use :Transformer, :value => :zlib\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n#### Rack-Cache\r\n\r\nYou can use Moneta as a [Rack-Cache](https://github.com/rtomayko/rack-cache) store. Use it in your `config.ru` like this:\r\n\r\n~~~ ruby\r\nrequire 'rack/cache/moneta'\r\n\r\nuse Rack::Cache,\r\n      :metastore   => 'moneta://Memory?expires=true',\r\n      :entitystore => 'moneta://Memory?expires=true'\r\n\r\n# Or used named Moneta stores\r\nRack::Cache::Moneta['named_metastore'] = Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\nuse Rack::Cache,\r\n      :metastore => 'moneta://named_metastore',\r\n      :entity_store => 'moneta://named_entitystore'\r\n~~~\r\n\r\n#### Cookies\r\n\r\nUse Moneta to store cookies in [Rack](http://rack.github.com/). It uses the `Moneta::Adapters::Cookie`. You might\r\nwonder what the purpose of this store or Rack middleware is: It makes it possible\r\nto use all the transformers on the cookies (e.g. `:prefix`, `:marshal` and `:hmac` for value verification).\r\n\r\n~~~ ruby\r\nrequire 'rack/moneta_cookies'\r\n\r\nuse Rack::MonetaCookies, :domain => 'example.com', :path => '/path'\r\nrun lambda { |env|\r\n  req = Rack::Request.new(env)\r\n  req.cookies #=> is now a Moneta store!\r\n  env['rack.request.cookie_hash'] #=> is now a Moneta store!\r\n  req.cookies['key'] #=> retrieves 'key'\r\n  req.cookies['key'] = 'value' #=> sets 'key'\r\n  req.cookies.delete('key') #=> removes 'key'\r\n  [200, {}, []]\r\n}\r\n~~~\r\n\r\n### Rails\r\n\r\n#### Session store\r\n\r\nAdd the session store in your application configuration `config/environments/*.rb`.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\n# Only by adapter name\r\nconfig.cache_store :moneta_store, :store => :Memory\r\n\r\n# Use Moneta.new\r\nconfig.cache_store :moneta_store, :store => Moneta.new(:Memory)\r\n\r\n# Use the Moneta builder\r\nconfig.cache_store :moneta_store, :store => Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n#### Cache store\r\n\r\nAdd the cache store in your application configuration `config/environments/*.rb`. Unfortunately the\r\nMoneta cache store doesn't support matchers. If you need these features use a different server-specific implementation.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\n# Only by adapter name\r\nconfig.cache_store :moneta_store, :store => :Memory\r\n\r\n# Use Moneta.new\r\nconfig.cache_store :moneta_store, :store => Moneta.new(:Memory)\r\n\r\n# Use the Moneta builder\r\nconfig.cache_store :moneta_store, :store => Moneta.build do\r\n  use :Expires\r\n  adapter :Memory\r\nend\r\n~~~\r\n\r\n------\r\n\r\n## Advanced\r\n\r\n### Build your own key value server\r\n\r\nYou can use Moneta to build your own key/value server which is shared between\r\nmultiple processes. If you run the following code in two different processes,\r\nthey will share the same data which will also be persistet in the database `shared.db`.\r\n\r\n~~~ ruby\r\nrequire 'moneta'\r\n\r\nstore = Moneta.build do\r\n  use :Transformer, :key => :marshal, :value => :marshal\r\n  use :Shared do\r\n    use :Cache do\r\n      cache do\r\n        adapter :LRUHash\r\n      end\r\n      backend do\r\n        adapter :GDBM, :file => 'shared.db'\r\n      end\r\n    end\r\n  end\r\nend\r\n~~~\r\n\r\nIf you want to go further, you might want to take a look at `Moneta::Server` and `Moneta::Adapters::Client` which\r\nare used by `Moneta::Shared` and provide the networking communication. But be aware that they are experimental\r\nand subjected to change. They provide an acceptable performance (for being ruby only), but don't have a stable protocol yet.\r\n\r\nYou might wonder why I didn't use [DRb](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/drb/rdoc/DRb.html) to implement server and client -\r\nin fact my first versions used it, but with much worse performance and it was real fun to implement the networking directly :)\r\nThere is still much room for improvement and experiments, try [EventMachine](http://eventmachine.rubyforge.org/),\r\ntry [Kgio](http://bogomips.org/kgio/), ...\r\n\r\n### ToyStore ORM\r\n\r\nIf you want something more advanced to handle your objects and relations,\r\nuse John Nunemaker's [ToyStore](https://github.com/jnunemaker/toystore) which works\r\ntogether with Moneta. Assuming that `Person` is a `ToyStore::Object` you can\r\nadd persistence using Moneta as follows:\r\n\r\n~~~ ruby\r\n# Use the Moneta Redis backend\r\nPerson.adapter :memory, Moneta.new(:Redis)\r\n~~~\r\n\r\n------\r\n\r\n## Testing and Benchmarks\r\n\r\nTesting is done using [Travis-CI](http://travis-ci.org/minad/moneta). Currently we support Ruby 1.8.7 and 1.9.3.\r\n\r\nBenchmarks for each store are done on [Travis-CI](http://travis-ci.org/minad/moneta) for each build. Take a look there\r\nto compare the speed of the different key value stores for different key/value sizes and size distributions.\r\nFeel free to add your own configurations! The impact of Moneta should be minimal since it is only a thin layer\r\non top of the different stores.\r\n\r\n------\r\n\r\n## Alternatives\r\n\r\n* [Horcrux](https://github.com/technoweenie/horcrux): Used at github, supports batch operations but only Memcached backend\r\n* [ActiveSupport::Cache::Store](http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html): The Rails cache store abstraction\r\n* [Padrino::Cache::Store](http://www.padrinorb.com/api/Padrino/Cache/Store.html): The Padrino cache store abstraction\r\n* [ToyStore](https://github.com/jnunemaker/toystore): ORM mapper for key/value stores\r\n* [ToyStore Adapter](https://github.com/jnunemaker/adapter): Adapter to key/value stores used by ToyStore, Moneta can be used directly with the ToyStore Memory adapter\r\n* [Cache](https://github.com/seamusabshere/cache): Rubygem cache wraps Memcached and Redis\r\n* [Ramaze::Cache](http://ramaze.net/documentation/Innate/Cache.html): Cache stores of the Ramaze framework with support for LocalMemCache, Memcached, Sequel, Redis, ...\r\n\r\n------\r\n\r\n## Authors\r\n\r\n* [Daniel Mendler](https://github.com/minad)\r\n* [Hannes Georg](https://github.com/hannesg)\r\n* Originally by [Yehuda Katz](https://github.com/wycats) and contributors\r\n","name":"Moneta","tagline":"a unified interface to key/value stores","google":""}